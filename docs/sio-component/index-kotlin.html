<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Le Langage  :: sio-slam</title>
    <meta name="description" content="Découverte et prise en main du langage Kotlin">
    <meta name="keywords" content="Kotlin langage programmation">
    <meta name="generator" content="Antora 3.0.1">
    <link rel="stylesheet" href="../_/css/site.css">
    <script>var uiRootPath = '../_'</script>
    <link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="..">
        <span> <img style="vertical-align: middle" src="../_/img/logo-sio-slam.png" alt="logo"> &nbsp;
        sio-slam
        </span>
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
<!--        <div class="navbar-item has-dropdown is-hoverable">-->
<!--          <a class="navbar-link" href="#">Products</a>-->
<!--          <div class="navbar-dropdown">-->
<!--            <a class="navbar-item" href="#">Product A</a>-->
<!--            <a class="navbar-item" href="#">Product B</a>-->
<!--            <a class="navbar-item" href="#">Product C</a>-->
<!--          </div>-->
<!--        </div>-->
<!--        <div class="navbar-item has-dropdown is-hoverable">-->
<!--          <a class="navbar-link" href="#">Services</a>-->
<!--          <div class="navbar-dropdown">-->
<!--            <a class="navbar-item" href="#">Service A</a>-->
<!--            <a class="navbar-item" href="#">Service B</a>-->
<!--            <a class="navbar-item" href="#">Service C</a>-->
<!--          </div>-->
<!--        </div>-->
        <a class="navbar-item" href="index-sio-slam.html">Année en cours</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download ?</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="sio-component" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index-glossaire.html">SIO-SLAM</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Présentation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-sio-slam.html">index sio slam</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="axe-directeur-2022-2023.html">schéma directeur</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Backend</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="todo-page.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="todo-page.html">Principles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="todo-page.html">Exemple</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="todo-page.html">Exercices</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Sous-categorie A</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="todo-page.html">item A.1</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="todo-page.html">item A.2</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="todo-page.html">item A.3</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Frontend</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-frontend.html">Intro</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="td0-intro-ts.html">Premiers pas en TypeScript</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="td1-hello-world.html">Angular Hello World &amp; Client API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="td2-multiplication.html">Angular Parent&#8594;Enfant &amp; Router&#8594;Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="td3-hackers.html">Angular Communication entre composants et Formulaire</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Programmation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="notion-fonction.html">Fonction - l&#8217;essentiel 1/2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-qualite.html">Facteurs de qualité</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Analyse</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-analyse.html">Conduire une analyse</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-sql.html">SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-nosql.html">NoSQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">UML (Unified Modeling Language)</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="index-uml.html">Présentation Générale</a>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="d_uc.html">Diagrammes UML</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="d_uc.html">Diagramme des cas d&#8217;utilisation</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="d_classe.html">Diagramme de classes</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">TP et activités</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="dc_tp1.html">TP N°1</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="_attachments/TP1_CORR.pdf">Corrigé TP1</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Projets</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="projet-0.html">Projet 0</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="projet-1.html">Projet 1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="projet-2.html">Projet 2</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Épreuves professionnelles</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="intro-epreuves.html">Présentation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="E4-CCF.html">E4 - CCF</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="E5-CCF.html">E5 - CCF</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="E6.html">E6 - épreuve nationale</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="intro-cybersecurite.html">Cybersecurite</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Activites.html">Activités</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Chiffrement_hachage.html">Chiffrement et hachage</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spring_security.html">Spring Security</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Kotlin</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="index-kotlin.html">Les bases de Kotlin</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Spring Boot Kotlin</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index-spring-boot.html">Initiation à Spring Boot</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-controles-exercices.html">Contrôles &amp; Exercices</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-glossaire.html">Glossaire</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">SIO-SLAM</span>
    <span class="version">default</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="index-glossaire.html">SIO-SLAM</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index-glossaire.html">default</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index-sio-slam.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index-glossaire.html">SIO-SLAM</a></li>
    <li>Kotlin</li>
    <li><a href="index-kotlin.html">Les bases de Kotlin</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://gitlab.com/ljules/doc_kotlin/edit/master/modules/ROOT/pages/index-kotlin.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Le Langage <span class="image"><img src="_images/Kotlin_logo_2021.png" alt="logo Kotlin" width="180"></span></h1>
<div id="toc" class="toc">
<div id="toctitle">Sommaire</div>
<ul class="sectlevel1">
<li><a href="#_présentation_origines">1. Présentation &amp; Origines</a>
<ul class="sectlevel2">
<li><a href="#_pourquoi_choisir_kotlin">1.1. Pourquoi choisir Kotlin ?</a></li>
<li><a href="#_références">1.2. Références</a></li>
</ul>
</li>
<li><a href="#_comment_coder_du_kotlin">2. Comment coder du Kotlin ?</a></li>
<li><a href="#_avant_propos">3. Avant-propos</a></li>
<li><a href="#_eléments_de_programmation_impérative_avec_kotlin">4. Eléments de programmation impérative avec Kotlin</a>
<ul class="sectlevel2">
<li><a href="#_point_dentrée_du_programme">4.1. Point d&#8217;entrée du programme</a></li>
<li><a href="#_les_variables_déclaration_affectation">4.2. Les variables (déclaration &amp; affectation)</a>
<ul class="sectlevel3">
<li><a href="#_un_langage_orienté_objet">4.2.1. Un langage orienté objet</a></li>
</ul>
</li>
<li><a href="#_apperçu_des_principaux_types">4.3. Apperçu des principaux types :</a>
<ul class="sectlevel3">
<li><a href="#_codage_des_valeurs_numériques">4.3.1. Codage des valeurs numériques :</a>
<ul class="sectlevel4">
<li><a href="#_les_attributs_min_value_max_value_et_syze_bytes">Les attributs MIN_VALUE; MAX_VALUE et SYZE_BYTES</a></li>
</ul>
</li>
<li><a href="#_booléens_caractères">4.3.2. Booléens &amp; caractères</a></li>
<li><a href="#_les_chaînes_de_caractères">4.3.3. Les chaînes de caractères</a></li>
<li><a href="#_les_tableauxarrays">4.3.4. Les tableaux(arrays) :</a></li>
<li><a href="#_les_collections">4.3.5. Les collections</a></li>
</ul>
</li>
<li><a href="#_les_déclarations_affectations_sur_les_variables">4.4. Les déclarations &amp; affectations sur les variables</a>
<ul class="sectlevel3">
<li><a href="#_rappel_sur_la_notion_de_référence">4.4.1. Rappel sur la notion de référence</a></li>
<li><a href="#_déclarations_affectations_du_type_boolean">4.4.2. Déclarations &amp; affectations du type Boolean</a></li>
<li><a href="#_déclarations_affectations_des_types_associés_aux_valeurs_numériques">4.4.3. Déclarations &amp; affectations des types associés aux valeurs numériques</a>
<ul class="sectlevel4">
<li><a href="#_cas_de_laffectation_du_type_float_avec_une_chaîne_numérique">Cas de l&#8217;affectation du type Float avec une chaîne numérique</a></li>
<li><a href="#_signature_des_chaînes_littérales_numériques">Signature des chaînes littérales numériques</a></li>
</ul>
</li>
<li><a href="#_déclarations_affectations_du_type_char_et_string">4.4.4. Déclarations &amp; affectations du type Char et String</a>
<ul class="sectlevel4">
<li><a href="#_le_type_char">Le type Char</a></li>
<li><a href="#_le_type_string">Le type String</a></li>
</ul>
</li>
<li><a href="#_conversions_de_types_transtypage">4.4.5. Conversions de types (transtypage)</a>
<ul class="sectlevel4">
<li><a href="#_conversions_entre_types_numériques">Conversions entre types numériques</a></li>
<li><a href="#_conversions_depuis_et_vers_le_type_string">Conversions depuis et vers le type String</a>
<ul class="sectlevel5">
<li><a href="#_conversions_vers_le_type_string">Conversions vers le type String</a></li>
<li><a href="#_conversion_depuis_le_type_string">Conversion depuis le type String</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_déclaration_affectations_du_type_array">4.4.6. Déclaration &amp; affectations du type Array</a>
<ul class="sectlevel4">
<li><a href="#_déclaration_dun_array">Déclaration d&#8217;un Array</a></li>
<li><a href="#_initialisation_dun_array">Initialisation d&#8217;un Array :</a></li>
<li><a href="#_tableau_à_plusieurs_dimensions_tableau_de_tableaux">Tableau à plusieurs dimensions (tableau de tableaux)</a></li>
<li><a href="#_affectation_des_valeurs_dun_array">Affectation des valeurs d&#8217;un Array</a></li>
</ul>
</li>
<li><a href="#_déclarations_affectations_sur_les_collections">4.4.7. Déclarations &amp; affectations sur les collections</a>
<ul class="sectlevel4">
<li><a href="#_tour_dhorizon_sur_les_collections">Tour d&#8217;horizon sur les collections</a></li>
<li><a href="#_le_type_list_listes">Le type List (listes)</a>
<ul class="sectlevel5">
<li><a href="#_déclaration_initialisation_dun_type_list">Déclaration &amp; initialisation d&#8217;un type List</a></li>
<li><a href="#_accès_en_lecture_écriture_aux_valeurs">Accès en lecture &amp; écriture aux valeurs</a></li>
<li><a href="#_ajout_et_suppression_de_valeurs_dune_liste_mutable">Ajout et suppression de valeurs d&#8217;une liste mutable</a></li>
</ul>
</li>
<li><a href="#_le_type_set_ensembles">Le type Set (ensembles)</a></li>
<li><a href="#_le_type_map_tableau_associatif">Le type Map (tableau associatif)</a></li>
</ul>
</li>
<li><a href="#_linférence_de_type">4.4.8. L&#8217;inférence de type</a></li>
<li><a href="#_cas_de_linitialisation_dune_variable_avec_null">4.4.9. Cas de l&#8217;initialisation d&#8217;une variable avec null</a></li>
<li><a href="#_déclaration_des_variables_constantes">4.4.10. Déclaration des variables constantes</a></li>
<li><a href="#_lentrée_standard_avec_readline_et_readln">4.4.11. L&#8217;entrée standard avec readLine() et readln()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_les_structuresexpressions_conditionnelles">5. Les structures/expressions conditionnelles</a>
<ul class="sectlevel2">
<li><a href="#_introduction_aux_expressions_et_structures_conditionnelles">5.1. Introduction aux Expressions et Structures Conditionnelles</a></li>
<li><a href="#_syntaxe_des_expressions_conditionnelles_ifelse_en_kotlin">5.2. Syntaxe des expressions conditionnelles if/else en Kotlin</a></li>
<li><a href="#_expression_conditionnelle_when">5.3. Expression conditionnelle when</a></li>
<li><a href="#_expression_conditionnelle_when_avec_des_plages">5.4. Expression conditionnelle when avec des plages</a></li>
</ul>
</li>
<li><a href="#_les_structures_itératives">6. Les structures itératives</a>
<ul class="sectlevel2">
<li><a href="#_généralités_sur_les_structures_itératives_en_kotlin">6.1. Généralités sur les structures itératives en Kotlin</a></li>
<li><a href="#_boucle_while">6.2. Boucle while</a></li>
<li><a href="#_boucle_do_while">6.3. Boucle do while</a></li>
<li><a href="#_boucle_forin">6.4. Boucle for(&#8230;&#8203;in&#8230;&#8203;)</a></li>
<li><a href="#_boucle_foreach">6.5. Boucle forEach</a></li>
<li><a href="#_choix_entre_forin_et_foreach">6.6. Choix entre for(&#8230;&#8203;in&#8230;&#8203;) et forEach</a></li>
</ul>
</li>
<li><a href="#_programmation_procédurale">7. Programmation procédurale</a>
<ul class="sectlevel2">
<li><a href="#_définition_appel_dune_fonction">7.1. Définition &amp; appel d&#8217;une fonction</a>
<ul class="sectlevel3">
<li><a href="#_avant_propos_2">7.1.1. Avant propos</a></li>
<li><a href="#_en_tête_de_la_fonction">7.1.2. En-tête de la fonction</a>
<ul class="sectlevel4">
<li><a href="#_en_tête_de_base">En-tête de base</a></li>
<li><a href="#_en_tête_avec_argument_par_défaut">En-tête avec argument par défaut</a></li>
<li><a href="#_en_tête_avec_nombre_darguments_variable">En-tête avec nombre d&#8217;arguments variable :</a></li>
<li><a href="#_mutabilité_des_paramètres_dune_fonction">Mutabilité des paramètres d&#8217;une fonction</a></li>
</ul>
</li>
<li><a href="#_corps_de_la_fonction">7.1.3. Corps de la fonction</a>
<ul class="sectlevel4">
<li><a href="#_corps_dune_fonction_de_base">Corps d&#8217;une fonction de base</a></li>
<li><a href="#_les_fonctions_expressions">Les fonctions expressions</a></li>
</ul>
</li>
<li><a href="#_appel_des_fonctions">7.1.4. Appel des fonctions</a></li>
<li><a href="#_les_fonctions_higher_order_functions_fonction_dordre_supérieur">7.1.5. Les fonctions "Higher-order functions" (fonction d&#8217;ordre supérieur)</a>
<ul class="sectlevel4">
<li><a href="#_définition_dune_fonction_dordre_supérieur">Définition d&#8217;une fonction d&#8217;ordre supérieur</a></li>
<li><a href="#_appel_dune_fonction_dordre_supérieur">Appel d&#8217;une fonction d&#8217;ordre supérieur</a></li>
</ul>
</li>
<li><a href="#_les_fonctions_lambdas_et_les_fonctions_anonymes">7.1.6. Les fonctions lambdas et les fonctions anonymes :</a>
<ul class="sectlevel4">
<li><a href="#_les_lambdas">Les lambdas</a></li>
<li><a href="#_utilisation_du_paramètre_it">Utilisation du paramètre it :</a></li>
<li><a href="#_les_fonctions_anonymes">Les fonctions anonymes</a></li>
</ul>
</li>
<li><a href="#_visibilité_des_fonctions">7.1.7. Visibilité des fonctions</a></li>
<li><a href="#_le_smartcast_transtypage_intelligent">7.1.8. Le smartCast (transtypage intelligent)</a>
<ul class="sectlevel4">
<li><a href="#_illustration_du_besoin_de_transtypage">Illustration du besoin de transtypage :</a></li>
<li><a href="#_test_dun_type_et_smartcast_avec_is">Test d&#8217;un type et smartCast avec is</a></li>
<li><a href="#_transtypage_avec_as">Transtypage avec as</a></li>
</ul>
</li>
<li><a href="#_les_fonctions_génériques">7.1.9. Les fonctions génériques</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_la_p_o_o_programmation_orientée_objet">8. La P.O.O. (Programmation Orientée Objet)</a>
<ul class="sectlevel2">
<li><a href="#_les_classes">8.1. Les classes</a>
<ul class="sectlevel3">
<li><a href="#_généralités">8.1.1. Généralités</a></li>
<li><a href="#_définition_déclaration_et_instanciation_dune_classe">8.1.2. Définition, déclaration et instanciation d&#8217;une classe</a></li>
<li><a href="#_définition_du_constructeur_primaire_dune_classe">8.1.3. Définition du constructeur primaire d&#8217;une classe</a>
<ul class="sectlevel4">
<li><a href="#_philosophie_dapproche_de_la_poo_avec_kotlin">Philosophie d&#8217;approche de la POO avec Kotlin</a></li>
<li><a href="#_le_constructeur_primaire">Le constructeur primaire</a></li>
</ul>
</li>
<li><a href="#_les_constructeurs_secondaires">8.1.4. Les constructeurs secondaires</a>
<ul class="sectlevel4">
<li><a href="#_avant_propos_3">Avant propos</a></li>
<li><a href="#_ordre_dappel_des_constructeurs">Ordre d&#8217;appel des constructeurs</a></li>
</ul>
</li>
<li><a href="#_structure_dune_classe_avec_constructeurs_secondaires">8.1.5. Structure d&#8217;une classe avec constructeurs secondaires</a></li>
</ul>
</li>
<li><a href="#_les_attributs_méthodes_de_classe_les_objets_compagnons">8.2. Les attributs &amp; méthodes de classe (Les objets compagnons)</a></li>
<li><a href="#_lhéritage">8.3. L&#8217;héritage</a>
<ul class="sectlevel3">
<li><a href="#_principes_de_base_de_lhéritage_en_kotlin">8.3.1. Principes de base de l&#8217;héritage en Kotlin</a></li>
<li><a href="#_ouvrir_une_classe_à_lhéritage">8.3.2. Ouvrir une classe à l&#8217;héritage</a></li>
<li><a href="#_héritage_dune_classe_de_base_vers_une_classe_dérivée">8.3.3. Héritage d&#8217;une classe de base vers une classe dérivée</a>
<ul class="sectlevel4">
<li><a href="#_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_sans_arguments">Mise en relation d&#8217;une classe dérivée avec une classe de base ayant un constructeur SANS arguments</a></li>
</ul>
</li>
<li><a href="#_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_avec_arguments">8.3.4. Mise en relation d&#8217;une classe dérivée avec une classe de base ayant un constructeur AVEC arguments</a></li>
<li><a href="#_enrichissement_dune_classe_dérivée_ajout_dattributs_et_de_méthodes">8.3.5. Enrichissement d&#8217;une classe dérivée : Ajout d&#8217;attributs et de méthodes</a></li>
<li><a href="#_redéfinition_des_attributs_etou_méthodes_dune_classe_de_base">8.3.6. Redéfinition des attributs et/ou méthodes d&#8217;une classe de base</a>
<ul class="sectlevel4">
<li><a href="#_redéfinition_des_attributs">Redéfinition des attributs</a></li>
<li><a href="#_redéfinition_des_méthodes">Redéfinition des méthodes</a></li>
</ul>
</li>
<li><a href="#_utilisation_du_mot_clé_super">8.3.7. Utilisation du mot clé super</a>
<ul class="sectlevel4">
<li><a href="#_accéder_à_une_méthodeattribut_redéfini">Accéder à une méthode/attribut redéfini</a></li>
<li><a href="#_appel_des_constructeurs_secondaires">Appel des constructeurs secondaires</a></li>
</ul>
</li>
<li><a href="#_les_classes_abstraites">8.3.8. Les classes abstraites</a>
<ul class="sectlevel4">
<li><a href="#_règles_propriétés_des_classes_abstraites">Règles &amp; propriétés des classes abstraites</a></li>
<li><a href="#_intérêt_des_classes_abstraites">Intérêt des classes abstraites</a></li>
</ul>
</li>
<li><a href="#_les_interfaces">8.3.9. Les interfaces</a>
<ul class="sectlevel4">
<li><a href="#_objectifs_et_principes_des_interfaces">Objectifs et principes des interfaces</a></li>
<li><a href="#_règles_propriétés_des_interfaces">Règles &amp; propriétés des interfaces</a></li>
</ul>
</li>
<li><a href="#_définition_dune_interface_en_kotlin">8.3.10. Définition d&#8217;une interface en Kotlin</a></li>
</ul>
</li>
<li><a href="#_les_extensions">8.4. Les extensions</a>
<ul class="sectlevel3">
<li><a href="#_objectifs_des_extensions">8.4.1. Objectifs des extensions</a></li>
<li><a href="#_principe_de_limplémentation_des_extensions">8.4.2. Principe de l&#8217;implémentation des extensions</a></li>
</ul>
</li>
<li><a href="#_allons_plus_loin_avec_les_classes">8.5. Allons plus loin avec les Classes</a>
<ul class="sectlevel3">
<li><a href="#_redéfinition_de_la_méthode_tostring_de_la_classe_any">8.5.1. Redéfinition de la méthode toString() de la classe Any</a></li>
<li><a href="#_les_data_class_classe_de_données">8.5.2. Les Data Class (classe de données)</a></li>
<li><a href="#_classes_anonymes_expressions_objets">8.5.3. Classes anonymes (expressions objets)</a>
<ul class="sectlevel4">
<li><a href="#_principe">Principe</a></li>
<li><a href="#_utilisation_du_mot_clé_object_définition_à_la_volée_dune_classe_from_scratch">Utilisation du mot clé object (définition à la volée d&#8217;une classe/ "from scratch")</a></li>
<li><a href="#_définition_à_la_volée_dune_classe_héritant_dune_classe_etou_interface">Définition à la volée d&#8217;une classe héritant d&#8217;une classe et/ou interface</a></li>
</ul>
</li>
<li><a href="#_les_énumérations">8.5.4. Les énumérations</a>
<ul class="sectlevel4">
<li><a href="#_principe_des_énumérations">Principe des énumérations</a></li>
<li><a href="#_définition_exploitation_des_énumérations">Définition &amp; exploitation des énumérations</a>
<ul class="sectlevel5">
<li><a href="#_accès_aux_objets_constants_de_lénumération_méthode_tostring">Accès aux objets constants de l&#8217;énumération (méthode toString() )</a></li>
<li><a href="#_méthode_valueof">Méthode valueOf()</a></li>
<li><a href="#_méthode_values">Méthode values()</a></li>
<li><a href="#_les_attributs_name_ordinal_des_objets_constants">Les attributs <strong>name</strong> &amp; <strong>ordinal</strong> des objets constants</a></li>
<li><a href="#_utilisation_de_la_boucle_when_avec_les_énumérations">Utilisation de la boucle <strong>when</strong> avec les énumérations</a></li>
</ul>
</li>
<li><a href="#_ajout_dattributs_aux_objets_constants_dune_énumération">Ajout d&#8217;attributs aux objets constants d&#8217;une énumération</a></li>
<li><a href="#_personnalisation_de_la_classe_dénumération">Personnalisation de la classe d&#8217;énumération</a></li>
<li><a href="#_redéfinir_une_méthode_selon_lobjet_constant_grâce_à_labstraction">Redéfinir une méthode selon l&#8217;objet constant grâce à l&#8217;abstraction</a></li>
<li><a href="#_utilisation_de_lhéritage_dinterfaces_avec_les_énumérations">Utilisation de l&#8217;héritage d&#8217;interfaces avec les énumérations</a></li>
</ul>
</li>
<li><a href="#_les_classes_scellées">8.5.5. Les classes scellées</a></li>
<li><a href="#_la_surcharge_dopérateurs">8.5.6. La surcharge d&#8217;opérateurs</a>
<ul class="sectlevel4">
<li><a href="#_principe_2">Principe</a></li>
<li><a href="#_surcharge_dopérateurs_unaires">Surcharge d&#8217;opérateurs unaires</a></li>
</ul>
</li>
<li><a href="#_surcharge_des_opérateurs_dincrémentationdécrémentation">8.5.7. Surcharge des opérateurs d&#8217;incrémentation/décrémentation</a>
<ul class="sectlevel4">
<li><a href="#_surcharge_dopérateurs_binaires">Surcharge d&#8217;opérateurs binaires</a></li>
</ul>
</li>
<li><a href="#_les_classes_génériques">8.5.8. Les classes génériques</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_présentation_origines"><a class="anchor" href="#_présentation_origines"></a>1. Présentation &amp; Origines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kotlin est un langage relativement relativement récent (2011). Il est dévellopé par l&#8217;éditeur JetBrains. Le nom du langage vient de l&#8217;île de Kotlin en Russie car l&#8217;équipe de développement était justement basé à St-Pétesbourg.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/ileKotlin.JPG" alt="localisation de Kotlin" width="500">
</div>
</div>
<div class="paragraph">
<p>L&#8217;objectif de Kotlin est d&#8217;offrir une alternative au langage Java tout en permettant le fonctionnement du code Java existant.<br>
Pour ce faire, Kotlin va être compilé en byte code pour la JVM. L&#8217;avantage est double :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin hérite naturellement du caractère multiplateforme de Java;</p>
</li>
<li>
<p>Les anciens programmes compilés à partir demeurent opérationnels, ce qui augure une existante parallèle des 2 langages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Sources :</em> <a href="https://fr.wikipedia.org/wiki/Kotlin_(langage)">Page Wikipédia de Kotlin</a></p>
</div>
<div class="sect2">
<h3 id="_pourquoi_choisir_kotlin"><a class="anchor" href="#_pourquoi_choisir_kotlin"></a>1.1. Pourquoi choisir Kotlin ?</h3>
<div class="paragraph">
<p>Kotlin se veut être un langage moderne afin de faciliter le développement d&#8217;application. Il garde les bases syntaxiques de Java mais en offrant les facilités de langages comme C# ou Python entres autres.</p>
</div>
<div class="paragraph">
<p><strong>Kotlin est appréciable par ses qualités intrinsèques :</strong></p>
</div>
<div class="paragraph">
<p>Programmation sur plusieurs paradigmes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Procédural;</strong></p>
</li>
<li>
<p><strong>Orienté Objet (POO);</strong></p>
</li>
<li>
<p><strong>Fonctionnel</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La syntaxe est plus concise là ou Java était un peu verbeu.</p>
</div>
<div class="paragraph">
<p>Simplification du développement car Kotlin permet de réaliser des automatisations comme par exemple la génération des accesseurs et mutateurs pour les attributs des classes.</p>
</div>
<div class="paragraph">
<p>Kotlin renforce les bonnes pratiques et la fiabilité du code développé.</p>
</div>
<div class="paragraph">
<p><strong>Kotlin est déjà un langage de référence :</strong></p>
</div>
<div class="paragraph">
<p>En 2017 Google adopte officiellement Kotlin comme second langage de dévellopement pour son OS Android. En 2019 Google fait passer Kotlin comme langage recommandé pour le développement sous Android.</p>
</div>
<div class="paragraph">
<p>Du côté serveur, le framework Spring supporte officiellement Kotlin en 2017.</p>
</div>
</div>
<div class="sect2">
<h3 id="_références"><a class="anchor" href="#_références"></a>1.2. Références</h3>
<div class="ulist">
<ul>
<li>
<p>Le site officiel : <a href="https://kotlinlang.org">Accueil Kotlin</a></p>
</li>
<li>
<p>Documentation officielle :  <a href="https://kotlinlang.org/docs/home.html">Documentation Kotlin</a></p>
</li>
<li>
<p>Le playground pour tester du code en ligne : <a href="https://play.kotlinlang.org/">Playground</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comment_coder_du_kotlin"><a class="anchor" href="#_comment_coder_du_kotlin"></a>2. Comment coder du Kotlin ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Le plus simple est d&#8217;utiliser IntelliJ IDEA de JetBrains. C&#8217;est l&#8217;IDE de prélidiction pour Java et encore plus pour développer Kotlin.</p>
</div>
<div class="paragraph">
<p>Il existe 2 version de cet IDE, la version gratuite (Community Edition) et la version payante (Ultimate).</p>
</div>
<div class="paragraph">
<p>Le téléchargement des 2 versions est disponible sur la page d&#8217;accueille d&#8217;IntelliJ : <a href="https://www.jetbrains.com/fr-fr/idea/">IntelliJ IDEA</a></p>
</div>
<div class="paragraph">
<p>Le compilateur sera fourni et prise en charge par IntelliJ.
Android Studio prend également en charge Kotlin pour le développement d&#8217;application</p>
</div>
<div class="paragraph">
<p>En cas d&#8217;utilisation d&#8217;un autre IDE ou éditeur de texte, il faudra installer le compilateur qui est mis à disposition sur GitHub. La documentation officielle consacre un partie sur l&#8217;utilisation de compilateur.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compilateur Kotlin : <a href="https://github.com/JetBrains/kotlin/releases">Releases sur GitHub</a></p>
</li>
<li>
<p>Documentation du compilateur : <a href="https://kotlinlang.org/docs/command-line.html">Doc du compilateur</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_avant_propos"><a class="anchor" href="#_avant_propos"></a>3. Avant-propos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kotlin est un langage multi-paradigmes (procédurale, POO et fonctionnel), cependant il ne laisse pas totalement le choix du paradigme. La logique globale était d&#8217;avoir un langage permettant de produire du code plus rapidement (syntaxe plus courte que Java) mais sécurisé. Pour arriver à ses fins Kotlin s&#8217;appuie sur une typage fort et un logique de programmation fonctionnelle.<br>
Il en résulte qu&#8217;il n&#8217;est pas aisé de segmenter totalement l&#8217;étude du langage, il faut aborder de front plusieurs éléments du langage pour comprendre certains mécanisme de ses instructions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_eléments_de_programmation_impérative_avec_kotlin"><a class="anchor" href="#_eléments_de_programmation_impérative_avec_kotlin"></a>4. Eléments de programmation impérative avec Kotlin</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_point_dentrée_du_programme"><a class="anchor" href="#_point_dentrée_du_programme"></a>4.1. Point d&#8217;entrée du programme</h3>
<div class="paragraph">
<p>Le paradigme de la POO n&#8217;étant pas imposé en Kotlin, nous ne sommes pas/plus obligé de créer une classe accueillant la méthode statique main().</p>
</div>
<div class="paragraph">
<p>Tout comme en C/C++ c&#8217;est la fonction main() qui est sert de point d&#8217;entrée.</p>
</div>
<div class="paragraph">
<p>La définition d&#8217;une fonction se fait avec le mot clé <strong class="yellow">fun</strong></p>
</div>
<div class="listingblock">
<div class="title">Hello World en Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println("Hello World !")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Comparaison avec la version Java :</p>
</div>
<div class="listingblock">
<div class="title">Hello World en Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java">class HelloWorld {

     public static void main(String[] args) {
        System.out.println("Hello World !");
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On constate les différences suivantes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pas de classe et donc pas de modificateur <strong><em>static</em></strong></p>
</li>
<li>
<p>On ne précise pas que la fonction <strong>main()</strong> ne retourne rien (absence de <strong><em>void</em></strong>)</p>
</li>
<li>
<p>Pas de point virgule <span class="red">;</span> pour marquer la fin d&#8217;une instruction, c&#8217;est le saut de ligne qui s&#8217;en charge.</p>
</li>
<li>
<p>La fonction <strong class="red">println()</strong> est directement accessible.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_les_variables_déclaration_affectation"><a class="anchor" href="#_les_variables_déclaration_affectation"></a>4.2. Les variables (déclaration &amp; affectation)</h3>
<div class="sect3">
<h4 id="_un_langage_orienté_objet"><a class="anchor" href="#_un_langage_orienté_objet"></a>4.2.1. Un langage orienté objet</h4>
<div class="paragraph">
<p>En Java nous avions la cohabitation de classes/objets avec des types primitifs.<br>
En Kotlin TOUTES les variables sont des objets. Même les données élémentaires comme les entiers, les flottans, les chaînes de caractères ou les booléens sont des instances de classes.<br>
Il en résulte que TOUS les types commencent par une majuscule afin de respecter la convention qu&#8217;un identifiant de classe commence par une majuscule.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong class="black">Le type Any :</strong> Toutes les classes héritent de la classe <strong class="black">Any</strong>. Donc tous les objets instanciés en Kotlin auront pour type commun le type <strong class="black">Any</strong>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apperçu_des_principaux_types"><a class="anchor" href="#_apperçu_des_principaux_types"></a>4.3. Apperçu des principaux types :</h3>
<div class="paragraph">
<p>Nous vous proposons de faire un petit tour d&#8217;horizon des principaux types de Kotlin avant d&#8217;explorer plus en détail les mécanismes de déclaration et d&#8217;affectation de chaque type.</p>
</div>
<div class="sect3">
<h4 id="_codage_des_valeurs_numériques"><a class="anchor" href="#_codage_des_valeurs_numériques"></a>4.3.1. Codage des valeurs numériques :</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Tous les types numériques héritent de classe <strong class="fuchsia">Number</strong>.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Codage des nombres entiers :</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MOT CLE DU TYPE</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>TAILLE MEMOIRE</strong> (bits)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>VALEUR MINI</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>VALEUR MAXI</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Byte</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Short</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-32 768</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32 767</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2<sup>31</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2<sup>31</sup>  - 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Long</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-2<sup>63</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2<sup>63</sup>  - 1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Rappel :</strong> En <strong>Java/Kotlin</strong> l&#8217;occupation maximale en mémoire (taille) ne dépend pas de la cible (OS &amp; machine).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Codage des nombres à virgule flottante :</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MOT CLE DU TYPE</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>TAILLE MEMOIRE</strong> (bits)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BITS MANTISSE</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BITS EXPOSANT</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Float</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Double</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">53</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
La comparaison de valeurs numériques en Kotlin ne peut se faire que <strong class="black">si les deux valeurs sont strictement du même type !</strong> Deux valeurs indentiques mais de types différents ne seront pas considérés comme égaux ! Voir exemple ci-dessous.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Exemple : Comparaison du type de 2 variables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val quinze_Int: Int = 15
    val quinze_Long: Long = 15

    // Vérification des types :
    println("quinze_Int is Int : ${quinze_Int is Int}")
    println("quinze_Long is Long : ${quinze_Long is Long}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tout se passe bien et on obtient le bon résultat dans la console.</p>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>quinze_Int is Int : true
quinze_Long is Long : true

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Ajoutons maintenant une instruction de comparaison d&#8217;égalité stricte.</p>
</div>
<div class="listingblock">
<div class="title">Ajout de la comparaison des valeurs des 2 variables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    println("quinze_Int == quinze_Long : ${quinze_Int == quinze_Long}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et là nous obtenons une erreur.
.Console :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Kotlin: Operator '==' cannot be applied to 'Int' and 'Long'</pre>
</div>
</div>
<div class="paragraph">
<p>On ne peut réaliser de comparaison d&#8217;égalité entre un objet de la classe Int et un objet de la classe Long.</p>
</div>
<div class="paragraph">
<p>Par contre on peut appliquer des comparaisons <strong class="red">&lt;</strong>, <strong class="red">&lt;=</strong>, <strong class="red">&gt;</strong> et <strong class="red">&gt;=</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong class="black">Quels types privilègier pour les valeurs numériques ? :</strong> Pour les valeurs entières il est conseillé d&#8217;utiliser le type <strong class="black">Int</strong> et pour les flottants le type <strong class="black">Double</strong>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_les_attributs_min_value_max_value_et_syze_bytes"><a class="anchor" href="#_les_attributs_min_value_max_value_et_syze_bytes"></a>Les attributs MIN_VALUE; MAX_VALUE et SYZE_BYTES</h5>
<div class="paragraph">
<p>Nous pouvons facilement retrouver les valeurs minimales et maximales que peut atteindre chaque type avec les attributs : <strong>MIN_VALUE</strong> et <strong>MAX_VALUE</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Exemple :</strong></p>
</div>
<div class="listingblock">
<div class="title">Utilisation de MIN_VALUE et MAX_VALUE :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(Int.MIN_VALUE)
    println(Int.MAX_VALUE)
    println(Long.MIN_VALUE)
    println(Long.MAX_VALUE)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>-2147483648
2147483647
-9223372036854775808
9223372036854775807

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>De même nous pouvons retrouver le nombre d&#8217;octets utilisés pour chaque type avec l&#8217;attribut <strong>SYZE_BYTES</strong>.</p>
</div>
<div class="paragraph">
<p><strong>Exemple :</strong></p>
</div>
<div class="listingblock">
<div class="title">Utilisation de SYZE_BYTES :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(Int.SIZE_BYTES) // 4
    println(Int.SIZE_BITS)  // 32
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>4
32

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_booléens_caractères"><a class="anchor" href="#_booléens_caractères"></a>4.3.2. Booléens &amp; caractères</h4>
<div class="paragraph">
<p>On trouve 2 autres types que sont les <strong>Booléens</strong> et les  <strong>Caractères</strong> :</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Codage des booléens et caractère</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MOT CLE DU TYPE</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>DESCRIPTION</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Boolean</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ne prend que 2 valeurs dites booléennes : <strong>true</strong> ou <strong>false</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="fuchsia">Char</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stock un caractère unique.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
En raison du typage fort de Kotlin on ne peut pas réaliser de tests logiques comme <strong>True == 1</strong> ou <strong>False == 0</strong> Le compilateur considéra que c&#8217;est une erreur.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_les_chaînes_de_caractères"><a class="anchor" href="#_les_chaînes_de_caractères"></a>4.3.3. Les chaînes de caractères</h4>
<div class="paragraph">
<p>Les chaînes de caractères sont <strong>immuables</strong> (non mutables) c&#8217;est-à-dire que vous ne pouvez pas modifier le contenu d&#8217;une chaînes de caractères une fois que la variable a reçu sa 1ère affectation.
Comme nous verrons plus tard, nous pourrons accéder aux différents caractères soit par une opération d&#8217;indexation ou avec une boucle d&#8217;itération (boucle de type foreach).</p>
</div>
</div>
<div class="sect3">
<h4 id="_les_tableauxarrays"><a class="anchor" href="#_les_tableauxarrays"></a>4.3.4. Les tableaux(arrays) :</h4>
<div class="paragraph">
<p>Les tableaux/arrays sont quasi équivalents aux tableaux de Java. Par contre les tableaux de Kotlin sont itérables (on peut les parcourir avec une boucle de type foreach).</p>
</div>
<div class="paragraph">
<p><span class="underline">Principales caractéristiques :</span></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Les valeurs sont mémorisées dans des zones <strong>contiguës</strong>  en mémoire, ce qui permet d&#8217;avoir un accès rapide aux valeurs.</p>
</li>
<li>
<p>La taille ne peut être modifiée (tableau statique).</p>
</li>
<li>
<p>Les valeurs sont <strong>ordonnées</strong> et <strong>indexées</strong> (accessibles par indice).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_les_collections"><a class="anchor" href="#_les_collections"></a>4.3.5. Les collections</h4>
<div class="paragraph">
<p>Kotlin nous offrent des collections qui facilitent le traitement des données.
Nous verrons que les collections pourront être déclarées comme <strong>mutables</strong> ou <strong>non mutables</strong>.</p>
</div>
<div class="paragraph">
<p>Toutes les collections de de Kotlin sont des types <strong>itérables</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>TYPE DE COLLECTION</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>DESCRIPTION</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>List</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Les listes ont un comportement similaire aux Arrays mais avec l&#8217;avantage d&#8217;être dynamique, c&#8217;est-à-dire que la taille est variable. En contre partie les temps d&#8217;accès sont plus importants.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Set</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Les sets sont équivalents aux ensembles mathématiques. C&#8217;est-à-dire que les valeurs sont <strong>non ordonnées</strong> et donc <strong>non indexées</strong>. 2 sets sont considérés égaux s&#8217;ils contiennent les mêmes valeurs indépendement de l&#8217;ordre des valeurs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Map</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Les maps sont des <strong>tableaux associatifs</strong>. Chaque valeur stockée est associée à une <strong>clé</strong>. Il est possible de vérifier la présence d&#8217;une clé et/ou valeur. Les maps sont itérables par contre ils sont non ordonnées (l&#8217;ordre est instable).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_les_déclarations_affectations_sur_les_variables"><a class="anchor" href="#_les_déclarations_affectations_sur_les_variables"></a>4.4. Les déclarations &amp; affectations sur les variables</h3>
<div class="paragraph">
<p><strong>Avant-propos :</strong></p>
</div>
<div class="paragraph">
<p>Kotlin se distingue principalement avec son mécanisme de déclaration des variables qui le singularise d&#8217;autres langages :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2 choix de déclaration :</p>
<div class="ulist">
<ul>
<li>
<p>Déclaration de valeurs mutables avec le mot clé <strong class="red">var</strong></p>
</li>
<li>
<p>Déclaration de valeurs non mutables avec le mot clé <strong class="red">val</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Typage statique mais possibilité <strong>d&#8217;inférence du type</strong> lors de la déclaration. C&#8217;est-à-dire que</p>
</li>
<li>
<p>La déclaration de variables <strong>null</strong> devra être "forcée".</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_rappel_sur_la_notion_de_référence"><a class="anchor" href="#_rappel_sur_la_notion_de_référence"></a>4.4.1. Rappel sur la notion de référence</h4>
<div class="paragraph">
<p>En Kotlin comme en Java chaque objet est accessible par une ou plusieurs références.</p>
</div>
<div class="paragraph">
<p><strong>Définition :</strong></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Référence :</strong> Variable contenant l&#8217;adresse d&#8217;un objet afin d&#8217;en permettre l&#8217;accès.</p>
</div>
<div class="paragraph">
<p><strong>Alias :</strong> Variable contenant l&#8217;adresse d&#8217;un objet déjà référencé par une 1ère variable.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ainsi lorsqu&#8217;on déclare une variable, celle-ci permettra de référencer un objet. La qualité de "mutabilité" d&#8217;une variable <strong>ne concernera pas les données</strong> mais les références des objets accuillant les données. Les données peuvent être modifiées si les méthodes des objets le permette.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_déclarations_affectations_du_type_boolean"><a class="anchor" href="#_déclarations_affectations_du_type_boolean"></a>4.4.2. Déclarations &amp; affectations du type Boolean</h4>
<div class="paragraph">
<p>Le type booléen est le type le plus simple et sera le parfait candidat pour nous initier aux régles d&#8217;affectation des variables/références.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la déclaration d&#8217;une variable mutable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">var idVar: typeIdVar</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;une déclaration sans affectation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    var varBinaire: Boolean  // Déclaration d'une référence mutable
    varBinaire = true        // Initialisation de la variable
    println(varBinaire)
    println(varBinaire is Boolean)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat de l&#8217;exécution</div>
<div class="content">
<pre>true
true

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>La variable varBinaire de notre exemple peut référencer que 2 objets Boolean : <strong>true</strong> ou <strong>false</strong></p>
</div>
<div class="listingblock">
<div class="title">Réaffectation de la variable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    var varBinaire: Boolean  // Déclaration d'une référence mutable
    varBinaire = true        // Initialisation de la variable
    println(varBinaire)
    println(varBinaire is Boolean)

    varBinaire = false      // Maintenant varBinaire référence un autre objet
    println(varBinaire)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat de l&#8217;exécution</div>
<div class="content">
<pre>true
true
false

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la déclaration d&#8217;une variable non mutable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">val idVar: typeIdVar</code></pre>
</div>
</div>
<div class="paragraph">
<p>La déclaraction d&#8217;une variable peut se faire sans initialisation. L&#8217;initialisation sera reportée à la 1ère affectation.
Par contre toute modification après la 1ère affectation déclenche une erreur.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de déclaration d&#8217;une variable non mutable</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    val varBinaire: Boolean  // Déclaration d'une référence NON mutable
    varBinaire = true        // Initialisation de la variable
    println(varBinaire)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Tentative de modification&#8230;&#8203;</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    val varBinaire: Boolean  // Déclaration d'une référence NON mutable
    varBinaire = true        // Initialisation de la variable

    varBinaire = false      // Tentative de réaffectation...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Message d&#8217;erreur affiché</div>
<div class="content">
<pre>Kotlin: Val cannot be reassigned</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
On verra plus en détail les mécanismes d&#8217;affectation par la suite. Avec notamment le mot clé <strong class="red">lateinit</strong> qui permet de différer l&#8217;initialisation d&#8217;une variable de sa déclaration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_déclarations_affectations_des_types_associés_aux_valeurs_numériques"><a class="anchor" href="#_déclarations_affectations_des_types_associés_aux_valeurs_numériques"></a>4.4.3. Déclarations &amp; affectations des types associés aux valeurs numériques</h4>
<div class="paragraph">
<p>La déclaration de variables numérique ne pose aucun problème. Voici la syntaxe à respecter pour déclarer une variable numérique mutable et non mutable :</p>
</div>
<div class="listingblock">
<div class="title">Instruction de déclaration de variables numériques mutables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var idVariable: type</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Application à tous les types numériques :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unByte: Byte        // Entier signé sous 8 bits.
    var unSshort: Short     // Entier signé sous 16 bits.
    var unEntierInt: Int    // Entier signé sous 32 bits.
    var unEntierLong: Long  // Entier signé sous 64 bits
    var unFlottant: Float   // Flottant signé sous 32 bits.
    var UnDouble: Double    // Flottant signé sous 64 bits.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Illustration du caractère "mutable" de la variable :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    var nombreTest: Long
    nombreTest = 165
    nombreTest = 54
    println(nombreTest)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Succés, la variable est réaffectée et affichée :</div>
<div class="content">
<pre>54

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Instruction de déclaration de variables numériques immuables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val idVariable: type</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Application à tous les types numériques :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val unByte: Byte        // Entier signé sous 8 bits.
    val unSshort: Short     // Entier signé sous 16 bits.
    val unEntierInt: Int    // Entier signé sous 32 bits.
    val unEntierLong: Long  // Entier signé sous 64 bits
    val unFlottant: Float   // Flottant signé sous 32 bits.
    val UnDouble: Double    // Flottant signé sous 64 bits.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Illustration du caractère immuable de la variable :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    val nombreTest: Long
    nombreTest = 165
    nombreTest = 54
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La réaffectation de la variable est naturellement refusé et génère une erreur d&#8217;exécution.</p>
</div>
<div class="listingblock">
<div class="title">Message d&#8217;erreur affiché</div>
<div class="content">
<pre>Kotlin: Val cannot be reassigned</pre>
</div>
</div>
<div class="sect4">
<h5 id="_cas_de_laffectation_du_type_float_avec_une_chaîne_numérique"><a class="anchor" href="#_cas_de_laffectation_du_type_float_avec_une_chaîne_numérique"></a>Cas de l&#8217;affectation du type Float avec une chaîne numérique</h5>
<div class="paragraph">
<p>L&#8217;affectation de valeur/chaînes numériques peut poser quelques soucis. En effet Kotlin affecte un type pour les constantes numériques (valeur/chaîne numériques). Il en découle que certaines affectations peuvent donc être refusées par le compilateur ! C&#8217;est notamment le cas lorsque l&#8217;on désire affecter une constante numérique à une variable déclarée comme un type <strong>Float</strong> !<br>
En effet Kotlin considère que les constantes numériques sont de type <strong>Double</strong>. Or affecter un <strong>Double</strong> dans un <strong>Float</strong> peut conduire à une potentielle troncature, d&#8217;où l&#8217;erreur levée à la compilation.</p>
</div>
<div class="listingblock">
<div class="title">Illustration de l&#8217;affectation d&#8217;une valeur numérique à une variable de type Float</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unFlottant: Float
    unFlottant = 43.2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Message d&#8217;erreur affiché à la compilation</div>
<div class="content">
<pre>Kotlin: The floating-point literal does not conform to the expected type Float</pre>
</div>
</div>
<div class="paragraph">
<p>Pour que Kotlin autorise l&#8217;affectation, il faut indiquer que le littérale représente une valeur correspondant au type Float. Pour ce faire il faut rajouter un <strong class="black">F</strong> ou un <strong class="black">f</strong> après le dernier chiffre du littéral.</p>
</div>
<div class="listingblock">
<div class="title">Affectation d&#8217;une valeur numérique (constante) marquée comme Float</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unFlottant: Float
    unFlottant = 43.2f</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_signature_des_chaînes_littérales_numériques"><a class="anchor" href="#_signature_des_chaînes_littérales_numériques"></a>Signature des chaînes littérales numériques</h5>
<div class="paragraph">
<p>Faison un petit tour des différentes possiblités d&#8217;écriture des chaînes numériques.</p>
</div>
<div class="paragraph">
<p><strong>Signature des Floats :</strong>
Nous vennons de le voir précédemmment, pour signer une valeur numérique en qualité de <strong>Float</strong> il faut utiliser :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong class="black">F</strong> ou <strong class="black">f</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exemples :</div>
<div class="content">
<pre>479.7825F
54.2089f</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Signature des Longs :</strong>
Les valeurs numériques sont implicitement au format Int. Pour désigner un Long, on terminera la chaîne numérique par un <strong>L</strong> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong class="black">L</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cette signature est moins utile que la précédente avec les <strong>Float</strong>. En effet ici nous pouvons affecter une chaîne littérale entière aussi bien un type <strong>Int</strong> (type d&#8217;origine de la chaîne numérique) et qui peut plus, peut le moins, donc le compilateur ne voit pas de problème à affecter un <strong>Int</strong> dans un <strong>Long</strong></p>
</div>
<div class="paragraph">
<p>On ne pourra rencontrer une erreur que si on signe effectivement notre chaîne numérique comme ci-dessous :</p>
</div>
<div class="listingblock">
<div class="title">Illustration  :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unInt: Int
    unInt = 13L</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nous nous retrouvons comme prévu avec une erreur :</p>
</div>
<div class="listingblock">
<div class="title">Erreur affiché :</div>
<div class="content">
<pre>Kotlin: The integer literal does not conform to the expected type Int</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ecriture scientifique/ingénieur et séparateur de millier :</strong></p>
</div>
<div class="paragraph">
<p>Pour faciliter la lecture des valeurs numérique Kotlin permet d&#8217;utiliser une écriture en puissance de 10 en utilisant le symbole <strong>e</strong> :</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unDouble: Double
    unDouble = 12.607e-6</code></pre>
</div>
</div>
<div class="paragraph">
<p>De même, il est possible d&#8217;utilise le tiret du bas (underscore) comme séparateur des milliers :</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var unDouble: Double
    unDouble = 3_987_124_051.0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Signature des valeurs au format binaire et hexadécimal :</strong></p>
</div>
<div class="paragraph">
<p>Vous pouvez saisir des chaînes numériques au format binaire ou hexadécimal.<br>
Il faut juste penser à les signer à gauche de la valeur :
* <strong>0b</strong> pour le format binaire
* <strong>0x</strong> pour le format hexadécimal</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    println(0b1111_1110)
    println(0x00_FE)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_déclarations_affectations_du_type_char_et_string"><a class="anchor" href="#_déclarations_affectations_du_type_char_et_string"></a>4.4.4. Déclarations &amp; affectations du type Char et String</h4>
<div class="sect4">
<h5 id="_le_type_char"><a class="anchor" href="#_le_type_char"></a>Le type Char</h5>
<div class="paragraph">
<p>Le type char permet de mémoriser un unique caractère unicode en mémoire.</p>
</div>
<div class="paragraph">
<p>La déclaration est sans particularité.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de déclaration de 2 variables de type Char :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var carMutable: Char    // Déclaration d'un caractère mutable.
    val carImmuable: Char   // Déclaration d'un caractère immuable.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour procéder à une affectation sur un Char nous pouvons :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Placer un caractère entre une paire de strophe <span class="red">' '</span></p>
</li>
<li>
<p>Utiliser le code Unicode du caractère au format <strong class="red">'\u</strong> <strong class="black"><em>numUnicode</em></strong> <strong class="red">'</strong>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;affections sur des variables de type Char :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var charAnd: Char = '&amp;'
    var charAndUnicode: Char = '\u0026'
    println("charAnd = $charAnd")
    println("charUnicode = $charAndUnicode")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage console du code :</div>
<div class="content">
<pre>charAnd = &amp;
charUnicode = &amp;

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_le_type_string"><a class="anchor" href="#_le_type_string"></a>Le type String</h5>
<div class="paragraph">
<p>Le type String n&#8217;a pas de particularité sur son processus de déclaration et d&#8217;affectation.
Le seul fait remarquable est qu&#8217;une chaîne de caractères ne peut-être modifiée, en pratique on réaffecte une nouvelle chaîne.</p>
</div>
<div class="paragraph">
<p>Dans la partie qui suit nous nous concentrons sur les processus de déclaration, d&#8217;initilisation d&#8217;accès et affectation à un caractère. Une autre partie est consacrée au boucle de parcours et principales méthodes de la classe String.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de déclarations sur des variables de type Char :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var uneLigneDeTexte: String // String mutable
    val unParagraphe: String    // String immuable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour l&#8217;affectation nous avons la syntaxe classique consistant à placer la chaîne de caractère entre 2 guillemets <strong class="red">" "</strong></p>
</div>
<div class="listingblock">
<div class="title">Affectation d&#8217;une chaîne sans saut de ligne :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    uneLigneDeTexte = "Bonjour à tous."</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affectation d&#8217;une chaîne sans avec saut de lignes :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    unParagraphe =  """ |Pour faciliter les sauts de lignes dans un String
                        |nous pouvons utiliser la méthode trimMargin().
                        |Fin du paragraphe.""".trimMargin()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Remarque :</strong> La méthode <strong>trimMargin()</strong> est facultative. Elle nous permet de supprimer les espaces et/ou tabulations placés avant le caractère <strong class="red">|</strong>.</p>
</div>
<div class="paragraph">
<p><strong class="underline">Accès à un caractère :</strong></p>
</div>
<div class="paragraph">
<p>Les objets de type String sont naturellement ordonnés et disposent d&#8217;un accès par indexation. Le 1er indice commence par 0.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    var texte = "Un, deux, trois, quatre, cinq"
    println(texte[4])
    //texte[4] = "D" // Ne fonctionne pas car les Strings sont toujours immuables

    // Il faut réaffecter une nouvelle chaîne si nous désirons la modifier :
    texte = texte.substring(0..3) + 'D' + texte.substring(5..28)
    println(texte)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conversions_de_types_transtypage"><a class="anchor" href="#_conversions_de_types_transtypage"></a>4.4.5. Conversions de types (transtypage)</h4>
<div class="sect4">
<h5 id="_conversions_entre_types_numériques"><a class="anchor" href="#_conversions_entre_types_numériques"></a>Conversions entre types numériques</h5>
<div class="paragraph">
<p>Kotlin permet le transtypage entre les différents types numériques (<strong>Byte</strong>, <strong>Short</strong>, <strong>Int</strong>, <strong>Long</strong>, <strong>Float</strong> et <strong>Double</strong>).</p>
</div>
<div class="paragraph">
<p>Evidemment un transtypage d&#8217;un type plus grand vers un plus petit pourra engendrer une erreur de débordement. De même la conversion d&#8217;un type de floattant (<strong>Float</strong> et <strong>Double</strong>) vers un type entier entraînera une troncature.</p>
</div>
<div class="paragraph">
<p>Kotlin encourage à favoriser les types <strong>Int</strong>, <strong>Long</strong> et <strong>Double</strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Kotlin ne proposera plus les conversions avec les méthodes <strong>toShort()</strong> et <strong>toByte()</strong> dans ses prochaines version&#8230;&#8203; Leur utilisation est découragée depuis la version 1.4 de Kotlin.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;utilisation des méthodes de transtypage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin"> // Les méthodes de transtypage/cast :
    var data01: Byte = 3
    var data02: Short = data01.toShort()
    var data03: Int = data01.toInt()
    var data04: Long = data01.toLong()
    var data05: Double = data01.toDouble()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_conversions_depuis_et_vers_le_type_string"><a class="anchor" href="#_conversions_depuis_et_vers_le_type_string"></a>Conversions depuis et vers le type String</h5>
<div class="sect5">
<h6 id="_conversions_vers_le_type_string"><a class="anchor" href="#_conversions_vers_le_type_string"></a>Conversions vers le type String</h6>
<div class="paragraph">
<p>Nous pouvons convertir vers le type String les types suivants :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Char</p>
</li>
<li>
<p>Int</p>
</li>
<li>
<p>Double</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">val n = 8     // Int
val d = 10.09 // Double
val c = '@'   // Char
val b = true  // Boolean

val s1 = n.toString() // "8"
val s2 = d.toString() // "10.09"
val s3 = c.toString() // "@"
val s4 = b.toString() // "true"</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_conversion_depuis_le_type_string"><a class="anchor" href="#_conversion_depuis_le_type_string"></a>Conversion depuis le type String</h6>
<div class="paragraph">
<p>Une valeur type String peut être convertie en nombre ou en booleen.
Pour la conversion en booleen, toute chaîne de caractères sera systématique convertien à l&#8217;état <strong>false</strong> sauf si la chaîne contient la chaîne "true" peut importe qu&#8217;une partie des lettres soient en majuscules/minuscules.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main() {
    println("abcd...".toBoolean())
    println("true".toBoolean())
    println("TRUE".toBoolean())
    println("True".toBoolean())
    println("tRuE".toBoolean())
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>false
true
true
true
true

Process finished with exit code 0</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
La conversion de String vers Char n&#8217;est pas possible en Kotlin.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_déclaration_affectations_du_type_array"><a class="anchor" href="#_déclaration_affectations_du_type_array"></a>4.4.6. Déclaration &amp; affectations du type Array</h4>
<div class="sect4">
<h5 id="_déclaration_dun_array"><a class="anchor" href="#_déclaration_dun_array"></a>Déclaration d&#8217;un Array</h5>
<div class="paragraph">
<p>Les Arrays doivent contenir des données qui auront tous le même type. L&#8217;instruction de déclaration des Array en Kotlin impose de préciser le type.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la déclaration d&#8217;un Array (tableau)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var idArray: Array&lt;type&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le type placé entre les chevrons <strong class="red">&lt; &gt;</strong> permet d&#8217;indiquer au compilateur le type des données à stocker.</p>
</div>
<div class="listingblock">
<div class="title">Exemples de déclaration de Tableaux (Arrays)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var tableau: Array&lt;Int&gt;           // Declaration d'un Array de Int
    var tableauFloat: Array&lt;Float&gt;    // Declaration d'un Array de Float
    var tableauChar: Array&lt;Char&gt;      // Declaration d'un Array de Char
    var tableauString: Array&lt;String&gt;   // Declaration d'un Array de String
    // Non exhaustif...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_initialisation_dun_array"><a class="anchor" href="#_initialisation_dun_array"></a>Initialisation d&#8217;un Array :</h5>
<div class="paragraph">
<p>La phase d&#8217;initialisation permet de définir la taille du tableau qui sera soit renseignée en dur, soit déduite d&#8217;un nombre d&#8217;éléments/valeurs à affecter.</p>
</div>
<div class="paragraph">
<p>Kotlin n&#8217;autorisera pas une instantiation sans initialisation avec des valeurs.</p>
</div>
<div class="paragraph">
<p>Nous avons trois manières de procéder :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Utiliser le constructeur <strong class="red">Array()</strong> de la classe <strong>Array</strong>;</p>
</li>
<li>
<p>Utiliser la fonction d&#8217;initialisation dédiée <strong class="red">arrayOf()</strong>;</p>
</li>
<li>
<p>Convertir un autre type de collection en <strong>Array</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong class="underline">Intialisation à partir du constructeur Array() :</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong class="black">Prérequis :</strong> L&#8217;utilisation du constructeur Array() nécessite de savoir définir une fonction lambda et de connaitre la variable d&#8217;itération <strong class="red">it</strong> est un plus.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Le constructeur Array() à besoin de 2 arguments pour réaliser l&#8217;initisation :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La taille du tableau;</p>
</li>
<li>
<p>Une fonction lambda qui permettra pour chaque indice de déterminer la valeur à renseigner.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;instruction d&#8217;initialisation d&#8217;un array :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">idRefTableau = Array(taille, lambda)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Une fonction lambda peut être placé juste après la fonction (quand elle placé en dernier paramètre) :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">idRefTableau = Array(taille)lambda</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple 1:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    // Déclaration de la référence :
    var tableauInt: Array&lt;Int&gt;

    // Initialisation d'un table de taille 5 contenant la valeur 9:
    tableauInt = Array(5, {9})

    // Affichage :
    println(tableauInt.contentToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage de la console :</div>
<div class="content">
<pre>[9, 9, 9, 9, 9]

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple 2:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation (le type est déduit par inférence) :
    var tableauInt = Array(5, {it}) // it est une variable d'itération générée automatiquement par Kotlin

    // Affichage :
    println(tableauInt.contentToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage de la console :</div>
<div class="content">
<pre>[0, 1, 2, 3, 4]

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple 3 :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation  :
    var tableauInt: Array&lt;Int&gt; = Array(5){3 * it}

    // Affichage :
    println(tableauInt.contentToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage de la console :</div>
<div class="content">
<pre>[0, 3, 6, 9, 12]

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong class="underline">Initialisation à partir de la fonction arrayOf() :</strong></p>
</div>
<div class="paragraph">
<p>Ici nous allons initialiser à partir d&#8217;une série de valeurs passées en argument de la fonction <strong>arrayOf()</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation  :
    var tableauInt = arrayOf("zéro", "un", "deux", "trois", "quatre")

    // Affichage :
    println(tableauInt.contentToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console  :</div>
<div class="content">
<pre>[zéro, un, deux, trois, quatre]

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong class="underline">Initialisation à partir de la conversion d&#8217;une autre collection :</strong></p>
</div>
<div class="paragraph">
<p>Voici un exemple où l&#8217;on génère une série numérique à l&#8217;aide d&#8217;une plage. Puis nous convertissons la plage en liste et la liste en tableau.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Une plage est une série de valeurs entières générées par l&#8217;instruction <strong class="red">(valDepart..valFin)</strong>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Génération d&#8217;un tableau à partir d&#8217;une plage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation  :
    var tableauInt = (5..10).toList().toTypedArray()

    // Affichage :
    println(tableauInt.contentToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[5, 6, 7, 8, 9, 10]

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_tableau_à_plusieurs_dimensions_tableau_de_tableaux"><a class="anchor" href="#_tableau_à_plusieurs_dimensions_tableau_de_tableaux"></a>Tableau à plusieurs dimensions (tableau de tableaux)</h5>
<div class="paragraph">
<p>Il est possible de générer des tableaux à n dimensions.</p>
</div>
<div class="listingblock">
<div class="title">Exemple avec la fonction arrayOf() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation d'un tableau de tableaux :
    var tableauDeTableaux = arrayOf(arrayOf(0, 1, 2, 3), arrayOf(4, 5, 6, 7), arrayOf(8, 9, 10, 11))
    // Affichage du contenu (attention il faut utiliser la méthode contentDeepToString ()):
    println(tableauDeTableaux.contentDeepToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple avec le constructeur Array() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation d'un tableau de tableaux :
    var tableauDeTableaux = Array(3){ Array(4){it} }
    // Affichage du contenu (attention il faut utiliser la méthode contentDeepToString ()):
    println(tableauDeTableaux.contentDeepToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]]

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_affectation_des_valeurs_dun_array"><a class="anchor" href="#_affectation_des_valeurs_dun_array"></a>Affectation des valeurs d&#8217;un Array</h5>
<div class="paragraph">
<p>Il y a aucune difficulté pour affecter au coup par coup des valeurs.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;affectation d&#8217;une valeur sur un indice i:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    idArray[i] = nouvelleValeur</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    //Déclaration &amp; initialisation d'un tableau de tableaux :
    val tableau = arrayOf("Zéro", "Un", "Deux")

    // Modification d'une valeur :
    tableau[1] = "1"

    // Affichage du contenu (attention il faut utiliser la méthode contentDeepToString ()):
    println(tableau.contentDeepToString())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[Zéro, 1, Deux]

Process finished with exit code 0</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
On a ici une bonne illustration que le mot clé <strong class="red">val</strong> protège la référence mais pas les attributs d&#8217;un objet puisque nous avons pu modifier une valeur d&#8217;un tableau.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_déclarations_affectations_sur_les_collections"><a class="anchor" href="#_déclarations_affectations_sur_les_collections"></a>4.4.7. Déclarations &amp; affectations sur les collections</h4>
<div class="sect4">
<h5 id="_tour_dhorizon_sur_les_collections"><a class="anchor" href="#_tour_dhorizon_sur_les_collections"></a>Tour d&#8217;horizon sur les collections</h5>
<div class="paragraph">
<p>Les collections nous permettent d&#8217;accéder à des structures de données dynamiques (la taille peut varier) et pourvus de méthodes permettant une étendu de traitement supérieur à celui des objets de la classe Array. Mais nous allons pouvoir pour chaque type de collection (list, set ou Map) l&#8217;initialiser comme mutable ou immuable les valeurs. Une collection immuable est une collection où il n&#8217;est pas possible de modifier les valeurs après leur initialisation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_le_type_list_listes"><a class="anchor" href="#_le_type_list_listes"></a>Le type List (listes)</h5>
<div class="paragraph">
<p>Ce type de collection est la plus proche du classique Array, elles ont donc quelques simularités.</p>
</div>
<div class="sect5">
<h6 id="_déclaration_initialisation_dun_type_list"><a class="anchor" href="#_déclaration_initialisation_dun_type_list"></a>Déclaration &amp; initialisation d&#8217;un type List</h6>
<div class="paragraph">
<p>A la différence des Array, les listes pourront être initialisée comme étant immuable ou mutable. C&#8217;est la fonction d&#8217;initialisation qui va affecter ce caractère à la liste instanciée. Ici le caractère de mutabilité concerne bien les valeurs stockée dans la liste. La mutabilité de la référence quant à elle repose toujours sur les mots clés <strong class="red">var</strong> et <strong class="red">val</strong>.
Nous opterons pour des références immuables dans nos prochains exemples.</p>
</div>
<div class="listingblock">
<div class="title"><strong>Listes immuables :</strong> Initialisations avec la fonction <strong>listOf()</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeImmuableString = listOf("zero", "un", "deux", "trois")
    val listeImmuableInt = listOf(0, 1, 2, 3)
    val listeImmuableVideInt = listOf&lt;Int&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il existe une fonction spécifique pour initialiser une liste immuable vide :</p>
</div>
<div class="listingblock">
<div class="title"><strong>Listes immmuables vides :</strong> Initialisation avec la fonction <strong>emptyList()</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeImmuableVideString = emptyList&lt;String&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nous pouvons également utiliser le constructeur :</p>
</div>
<div class="listingblock">
<div class="title"><strong>Liste immuable :</strong> Initialisation avec le constructeur</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeConstruite = List(5){it} // Instance d'une liste de 5 éléments</code></pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;affichage du contenu d&#8217;une liste peut se faire en passant directement l&#8217;identifiant de la liste en argument de la fonction <strong>print()</strong> ou <strong>println()</strong></p>
</div>
<div class="listingblock">
<div class="title">*Exemple d&#8217;instruction d&#8217;affichage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    println(listeImmuableString)
    println(listeImmuableInt)
    println(listeImmuableVideInt)
    println(listeConstruite)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage dans la console :</div>
<div class="content">
<pre>[zero, un, deux, trois]
[0, 1, 2, 3]
[]
[0, 1, 2, 3, 4]

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title"><strong>Listes mutables :</strong> Initialisation avec la fonction <strong>mutableListOf()</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeMutableString = mutableListOf("zero", "un", "deux", "trois")
    val listeMutableInt = mutableListOf(0, 1, 2, 3)
    val listeMutableVideInt = mutableListOf&lt;Int&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mais nous pouvons aussi procéder à l&#8217;initialisation avec le constructeur <strong>MutableList()</strong> qui fonctionne comme sa version immuable <strong>List()</strong>.</p>
</div>
<div class="listingblock">
<div class="title"><strong>Listes mutables :</strong> Initialisation avec le constructeur <strong>MutableList()</strong></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeConstruireMutable = MutableList(5){it}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_accès_en_lecture_écriture_aux_valeurs"><a class="anchor" href="#_accès_en_lecture_écriture_aux_valeurs"></a>Accès en lecture &amp; écriture aux valeurs</h6>
<div class="paragraph">
<p>Le principe est identique à celui des Arrays. On peut accéder à chacun des éléments par son indice. On peut modifier la valeur</p>
</div>
<div class="listingblock">
<div class="title">Exemples :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeImmuable = listOf("zéro", "un", "deux", "trois")
    val listeMutable = mutableListOf("zéro", "un", "deux", "trois")

    println(listeImmuable[2])
    listeMutable[2] = "DEUX"
    println(listeMutable[2])</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>deux
DEUX

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ajout_et_suppression_de_valeurs_dune_liste_mutable"><a class="anchor" href="#_ajout_et_suppression_de_valeurs_dune_liste_mutable"></a>Ajout et suppression de valeurs d&#8217;une liste mutable</h6>
<div class="paragraph">
<p>Le 1er intérêt des listes par rapport au type Array est la possibilité de rajouter ou supprimer des valeurs.</p>
</div>
<div class="listingblock">
<div class="title">Ajout et suppresion de valeurs :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val listeMutable = mutableListOf("zéro", "un", "deux", "trois")

    // Ajout d'une valeur avec l'opérateur +=
    listeMutable += "QUATRE"

    // Ajout d'une valeur avec la méthode add()
    listeMutable.add("SIX")
    listeMutable.add(5, "CINQ") // Insertion à l'indice 5

    println(listeMutable)

    // Suppression d'une valeur
    listeMutable.removeAt(2)          // Suppression de la valeur à l'indice 2
    listeMutable.remove("QUATRE")   // Suppression de la valeur "QUATRE"

    println(listeMutable)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console</div>
<div class="content">
<pre>[zéro, un, deux, trois, QUATRE, CINQ, SIX]
[zéro, un, trois, CINQ, SIX]

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_le_type_set_ensembles"><a class="anchor" href="#_le_type_set_ensembles"></a>Le type Set (ensembles)</h5>
<div class="paragraph">
<p>Le type Set est très semblable au type List, la différence vient du fait que l&#8217;on respecte les principes d&#8217;un ensemble :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>L&#8217;ordre des valeurs ne doit pas être pris en compte (structure non ordonnée);</p>
</li>
<li>
<p>On ne doit pas accepter de doublons.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exemple de Sets immuables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val setImmuable = setOf("un", "deux", "deux","trois", "quatre", "un") // Les 2 doublons seront éliminés
    val setDesordre = setOf("deux", "trois", "quatre", "un")

    println(setImmuable)
    println("trois est-il dans l'ensemble : ${"trois" in setImmuable}")
    println("Les 2 ensembles sont-ils égaux : ${setDesordre == setImmuable}")

    // setImmuable[2] est interdit, mais nous pouvons utiliser elementAt() :
    println(setImmuable.elementAt(2))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[un, deux, trois, quatre]
trois est-il dans l'ensemble : true
Les 2 ensembles sont-ils égaux : true
trois

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Les Sets mutables vont permettre d&#8217;ajouter des valeurs comme avec une liste. Mais la présence de doublons reste impossible pour respecter l&#8217;unicité des valeurs.</p>
</div>
<div class="listingblock">
<div class="title">Exemple sur les Sets mutables :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val setMutable = mutableSetOf("un", "deux", "deux","trois", "quatre", "un") // Les 2 doublons seront éliminés
    setMutable += "un"
    setMutable.add("cinq")
    println(setMutable)
    setMutable.remove("trois")
    println(setMutable)
    println(setMutable.elementAt(2))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>[un, deux, trois, quatre, cinq]
[un, deux, quatre, cinq]
quatre

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_le_type_map_tableau_associatif"><a class="anchor" href="#_le_type_map_tableau_associatif"></a>Le type Map (tableau associatif)</h5>
<div class="paragraph">
<p>Le type Map est un tableau associatif, c&#8217;est-à-dire que dans un tableau sont stockées des valeurs. Chaque valeur est associée à une clé pour permettre son accès au lieu d&#8217;utiliser un numéro d&#8217;indice.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    // Création d'un map :
    var tabAssoImmuable = mapOf(0 to "Zero", 1 to "Une", 2 to "Deux", 3 to "Trois")
    var tabAssoMutable = mutableMapOf(0 to "Zero", 1 to "Une", 2 to "Deux", 3 to "Trois")

    // Exploitation :
    println("Exemple avec tabAssoImmuable : $tabAssoImmuable")
    println("tabAssoImmuable.keys : ${tabAssoImmuable.keys}")
    println("tabAssoImmuable.values : ${tabAssoImmuable.values}")

    // Accès par clé :
    println("Valeur à la clée 2 : tabAssoImmuable[2] = ${tabAssoImmuable[2]}")

    // Vérification présence clé :
    println("La clée 1 est-elle dans tabAssoImmuable : ${1 in tabAssoImmuable}")
    println("La clée 7 est-elle dans tabAssoImmuable : ${7 in tabAssoImmuable}")

    // Vérification présence valeur :
    println("La valeur \"Deux\" est-elle dans tabAssoImmuable : ${"Deux" in tabAssoImmuable.values}")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>Exemple avec tabAssoImmuable : {0=Zero, 1=Une, 2=Deux, 3=Trois}
tabAssoImmuable.keys : [0, 1, 2, 3]
tabAssoImmuable.values : [Zero, Une, Deux, Trois]
Valeur à la clée 2 : tabAssoImmuable[2] = Deux
La clée 1 est-elle dans tabAssoImmuable : true
La clée 7 est-elle dans tabAssoImmuable : false
La valeur "Deux" est-elle dans tabAssoImmuable : true

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_linférence_de_type"><a class="anchor" href="#_linférence_de_type"></a>4.4.8. L&#8217;inférence de type</h4>
<div class="paragraph">
<p>Kotlin offre un mécanisme d&#8217;inférence de type. L&#8217;inférence de type consiste à laisser déterminer le type d&#8217;une variable par le compilateur.<br>
Le compilateur exploite le contexte pour déterminer le type. Par exemple il pourra déduire le type avec les valeurs d&#8217;intialisation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
L&#8217;inférence de type diffère du typage dynamique que l&#8217;on retrouve dans des langages comme Python ou Java Script. L&#8217;inférence de type et le typage dynamique permettent de ne pas indiquer le type au moment de sa déclaration. Cependant en typage dynamique, le type de la variable pourra évoluer durant l&#8217;exécution du programme. L&#8217;inférence de type respecte le typage statique, le type est affecté au moment de la compilation et ne pourra plus changer par la suite.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_cas_de_linitialisation_dune_variable_avec_null"><a class="anchor" href="#_cas_de_linitialisation_dune_variable_avec_null"></a>4.4.9. Cas de l&#8217;initialisation d&#8217;une variable avec null</h4>
<div class="paragraph">
<p>Initialiser une variable comme étant <strong><em>null</em></strong> peut mener à des erreurs durant le déroulement de nos programmes.</p>
</div>
<div class="paragraph">
<p>Kotlin décourage à cette pratique mais ne l&#8217;interdit pas. Pour ce faire il refusera qu&#8217;une variable soit affectée avec * <em>null</em>*.</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;une déclaration d&#8217;un type Int avec null</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    var uneVariable: Int = null
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Erreur produite :</div>
<div class="content">
<pre>Kotlin: Null can not be a value of a non-null type Int</pre>
</div>
</div>
<div class="paragraph">
<p>Cependant nous pouvons forcer les choses, pour ce faire il faut rajouter le symbole <span class="red">?</span> après la déclaration du type de la variable.</p>
</div>
<div class="paragraph">
<p>De même, si la variable est utilisée sans que le compilateur puisse s&#8217;assurer que la variable prendre bien une valeur quelconque mais différente de <strong>null</strong>, alors une erreur sera levée.
Nous pouvons choisir de faire ignorer cette vérification en plaçant un double !! après l&#8217;identifiant de la variable initialisée à <strong>null</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;initialisation d&#8217;une variable avec null en utilisant ? et de son utilisation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun demo(uneVariable: Int){println("La variable initialisée à null vaut maintenant : ${uneVariable}")}

fun main(){
    var uneVariable: Int? = null
    if (true) uneVariable = 33 // La structure conditionnelle rend incertain pour le compilateur de la valeur de la variable au moment de l'exécution.
    demo(uneVariable!!)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_déclaration_des_variables_constantes"><a class="anchor" href="#_déclaration_des_variables_constantes"></a>4.4.10. Déclaration des variables constantes</h4>
<div class="paragraph">
<p>Nous avons vu que nous pouvions déclarer des variables comme étant immuables avec le mot clé <strong class="red">val</strong>.<br>
Cependant une "vraie" constante doit être initialisée au moment de la compilation selon les régles de l&#8217;art. Kotlin permet d&#8217;imposer ce mode de fonctionnement avec le mot clé <strong class="red">const</strong>.</p>
</div>
<div class="paragraph">
<p>La variable sera alors déclarée endehors du corps de la fonction <strong>main()</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;initialisation d&#8217;une variable constante avec const</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">const val ID_CONSTANTE = valeurInitialisation</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;utilisation de const</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">const val MAXIMUM = 37

fun main(){
    println("La constante MAXIMUM : $MAXIMUM")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>La constante MAXIMUM : 37

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lentrée_standard_avec_readline_et_readln"><a class="anchor" href="#_lentrée_standard_avec_readline_et_readln"></a>4.4.11. L&#8217;entrée standard avec readLine() et readln()</h4>
<div class="paragraph">
<p>Kotlin dispose de la fonction <strong>readLine()</strong> pour permettre la lecture de valeur dans la console.
La fonction readLine() retourne systématique la saisie sous la forme d&#8217;un <strong>String</strong>.</p>
</div>
<div class="paragraph">
<p>La fonction readLine() peut retourner le type <strong>null</strong> si la touche entrée est frappée sans aucune entrée préalable.</p>
</div>
<div class="paragraph">
<p>Il existe depuis la version 1.6 de Kotlin une variante court de <strong>readLine()</strong> qui est <strong>readln()</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Utilisation de readLine() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main() {
    val line = readLine()!!
    println(line)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Résultat :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Coucou
Coucou

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_les_structuresexpressions_conditionnelles"><a class="anchor" href="#_les_structuresexpressions_conditionnelles"></a>5. Les structures/expressions conditionnelles</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_aux_expressions_et_structures_conditionnelles"><a class="anchor" href="#_introduction_aux_expressions_et_structures_conditionnelles"></a>5.1. Introduction aux Expressions et Structures Conditionnelles</h3>
<div class="paragraph">
<p>Kotlin n&#8217;utilise pas des structures conditionnelles mais des expressions conditionnelles. Les deux concepts sont très proches mais également subtilement différents. Prenons un petit moment pour les expliquer.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Définition d&#8217;une structure conditionnelle :</strong> Une structure conditionnelle conditionne une instruction ou un bloc d&#8217;instructions selon qu&#8217;une  ou plusieurs condition(s) logique(s) (prédicat(s)) soit vérifiée(s) ou non (proposition vraie ou fausse).<br>
La condition logique peut être par exemple l&#8217;état d&#8217;une variable booléenne, le résultat d&#8217;une expression logique, l&#8217;état d&#8217;une entrée logique d&#8217;un système.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Définition d&#8217;une expression conditionnelle :</strong> Une expression conditionnelle conditionne une le résultat d&#8217;une valeur selon l&#8217;état d&#8217;une ou plusieurs condition(s) logique(s).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>En d&#8217;autres termes, une expression conditionnelle pourra être placée en argument d&#8217;une fonction ou à l&#8217;affectation d&#8217;une variable par exemple.</p>
</div>
<div class="paragraph">
<p>Une expression conditionnelle peut également être utilisée en remplacement d&#8217;une structure conditionnelle alors que la réciproque n&#8217;est pas vraie.</p>
</div>
</div>
<div class="sect2">
<h3 id="_syntaxe_des_expressions_conditionnelles_ifelse_en_kotlin"><a class="anchor" href="#_syntaxe_des_expressions_conditionnelles_ifelse_en_kotlin"></a>5.2. Syntaxe des expressions conditionnelles if/else en Kotlin</h3>
<div class="paragraph">
<p>Les mots clés utilisés sont identiques que dans les langages de type C/C++/Java : <strong class="red">if</strong> /<strong class="red">else</strong></p>
</div>
<div class="paragraph">
<p>Voici un exemple illustrant la différent entre une expression et une structure conditionnelle :</p>
</div>
<div class="listingblock">
<div class="title">Structure conditionnelle :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val decision: Boolean = false
    // Structure conditionnelle :
    if(decision){
        println("Oui !")
    }
    else{
        println("Non !")
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ici nous avons une structure conditionnelle classique, avec le choix de 2 instructions <strong>println("Oui !")</strong> ou <strong>println("Non !")</strong>.</p>
</div>
<div class="paragraph">
<p>Nous pouvons remplacer cette structure conditionnelle par une expression conditionnelle :</p>
</div>
<div class="listingblock">
<div class="title">Expression conditionnelle :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    // Expression conditionnelle :
    val decision: Boolean = false
    println(if(decision) "Oui !" else "Non!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>La version en expression conditionnelle est plus élégante. En effet ici l&#8217;élément variant est bien la chaîne de caractère <strong>"Oui !"</strong>/<strong>"Non !"</strong>. La fonction <strong>println()</strong> est redondante dans la version structure conditionnelle.</p>
</div>
<div class="paragraph">
<p>Une expression conditionnelle peut également comporter plusieurs instructions regroupées en bloc. Il faut juste que la dernière instruction corresponde à une expression.</p>
</div>
<div class="listingblock">
<div class="title">Expression conditionnelle avec bloc d&#8217;instructions :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var a = 1
    var b = 2

    var resultat = if (a &lt; b){
        a = b
        2 * b
    }
    else{
        b = a
        2 * a
    }
    println(resultat)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expression_conditionnelle_when"><a class="anchor" href="#_expression_conditionnelle_when"></a>5.3. Expression conditionnelle when</h3>
<div class="paragraph">
<p>L&#8217;expression conditionnelle remplace la structure conditionnelle switch case que nous retrouvions dans de nombreux langage.
On obtient le même résultat avec une syntaxe plus concise.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var varCandidate: String =  when(y){
        1 -&gt; "un"
        2 -&gt; "deux"
        7 -&gt; "sept"

        else -&gt;{    // Le else est obligatoire et se place dans le bloc du when.
            "On ne sait pas !"
        }
    }
    print("varCandidate = $varCandidate")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expression_conditionnelle_when_avec_des_plages"><a class="anchor" href="#_expression_conditionnelle_when_avec_des_plages"></a>5.4. Expression conditionnelle when avec des plages</h3>
<div class="paragraph">
<p>Kotlin introduit une instruction nommée plage qui permet de réaliser des itérations avec une boucle (voir structures itératives), mais également de définir des intervalles comme conditions.
Nous pouvons également mixer valeurs et plages.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var cible = -8

    var resultat = when(cible) {
        in -10..-5 -&gt; "Trop négatif"
        in -4..-1 -&gt; "Faiblement négatif"
        0 -&gt; "Nul"
        in 1..5 -&gt; "Faiblement positif"
        in 6..10 -&gt; "Trop positif"
        else -&gt; {"Hors valeurs !"}  // Attention le else est dans le bloc principal du when
    }
    println(resultat)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_les_structures_itératives"><a class="anchor" href="#_les_structures_itératives"></a>6. Les structures itératives</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_généralités_sur_les_structures_itératives_en_kotlin"><a class="anchor" href="#_généralités_sur_les_structures_itératives_en_kotlin"></a>6.1. Généralités sur les structures itératives en Kotlin</h3>
<div class="paragraph">
<p>Kotlin propose plusieurs possibilités pour réaliser des structures itératives. On retrouve les instructions suivantes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La boucle <strong class="red">while</strong> et <strong class="red">do while</strong> (boucle non bornée) : Kotlin ne propose pas d&#8217;innovation, c&#8217;est une classique boucle dont la fin dépend d&#8217;une proposition logique.</p>
</li>
<li>
<p>La boucle <strong class="red">for(&#8230;&#8203;in&#8230;&#8203;)</strong> : C&#8217;est une boucle de type <strong>for each</strong> qui permet d&#8217;itérer sur des collections et des plages par exemple. Par contre la boucle bornée for(int = 0; i &lt; n; i++) disparait et est remplacée par l&#8217;utilisation de la boucle for avec une plage.</p>
</li>
<li>
<p>La boucle <strong class="red">forEach</strong> : C&#8217;est une boucle spécifique pour les <strong>collections</strong>, on peut aussi l&#8217;utiliser avec des plages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_boucle_while"><a class="anchor" href="#_boucle_while"></a>6.2. Boucle while</h3>
<div class="paragraph">
<p>Rien de particulier pour ce type de structure itérative. La syntaxe est conventionnelle :</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la boucle while :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    while(condition){
        // Instructions à itérer
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;une boucle de comptage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var i: Int = 0
    while( i &lt; 10) {
        println("Iteration while n°$i")
        i++
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_boucle_do_while"><a class="anchor" href="#_boucle_do_while"></a>6.3. Boucle do while</h3>
<div class="paragraph">
<p>On reste encore classique au niveau de la syntaxe :</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la boucle do while :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    do{
        // Instruction à itérer...
    }while (condition)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;une boucle de comptage avec do while :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var i: Int = 0
    do{
        println("Iteration do while n°$i")
        i++
    } while (i &lt; 10)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_boucle_forin"><a class="anchor" href="#_boucle_forin"></a>6.4. Boucle for(&#8230;&#8203;in&#8230;&#8203;)</h3>
<div class="paragraph">
<p>C&#8217;est la boucle de prélidiction pour réaliser des itérations bornées. On peut également l&#8217;appliquer au contenu de collections, mais dans ce cadre le boucle forEach offre de meilleures performances.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de la boucle for(&#8230;&#8203;in&#8230;&#8203;) :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    for(item in itérable){
        // Instruction à itérer
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemples sur des collections (List, Map et Set)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val liste = listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    val ensemble = setOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    val tabAssociatif = mapOf(1 to "un", 2 to "deux", 3 to "trois", 4 to "quatre")

    for (elmt in liste) {
        println(elmt)
    }
    for (elmt in ensemble){
        println(elmt)
    }

    for(elmt in tabAssociatif){
        println(elmt)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nous pouvons appliquer la boucle for(&#8230;&#8203;in&#8230;&#8203;) à une plage.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de boucles for(&#8230;&#8203;in&#8230;&#8203;) sur une plage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotling hljs" data-lang="Kotling">    for(i in 0..10){print(i)}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_boucle_foreach"><a class="anchor" href="#_boucle_foreach"></a>6.5. Boucle forEach</h3>
<div class="paragraph">
<p>La boucle forEach est particulièrement intéressante avec les collections.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de forEach</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    iterable.foreach{lambda}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemples sur des collections :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val liste = listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    val ensemble = setOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    val tabAssociatif = mapOf(1 to "un", 2 to "deux", 3 to "trois", 4 to "quatre")

    liste.forEach { println(it) }
    ensemble.forEach { println(it) }
    tabAssociatif.forEach { println(it) }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple sur une plage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    (0..10).forEach { println(it) }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_choix_entre_forin_et_foreach"><a class="anchor" href="#_choix_entre_forin_et_foreach"></a>6.6. Choix entre for(&#8230;&#8203;in&#8230;&#8203;) et forEach</h3>
<div class="paragraph">
<p>La boucle forEach offre de meilleures performances pour réaliser des itération sur des collections. Par contre pour réaliser des boucles à partir d&#8217;une plage c&#8217;est la boucle for(&#8230;&#8203;in&#8230;&#8203;) qui est plus intéressante en terme de performance.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programmation_procédurale"><a class="anchor" href="#_programmation_procédurale"></a>7. Programmation procédurale</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_définition_appel_dune_fonction"><a class="anchor" href="#_définition_appel_dune_fonction"></a>7.1. Définition &amp; appel d&#8217;une fonction</h3>
<div class="sect3">
<h4 id="_avant_propos_2"><a class="anchor" href="#_avant_propos_2"></a>7.1.1. Avant propos</h4>
<div class="paragraph">
<p>Nous avons pris le parti de segmenter en 3 parties les composantes de la programmation procédurales :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>En-tête d&#8217;une fonction</p>
</li>
<li>
<p>Corps d&#8217;une fonction</p>
</li>
<li>
<p>Appel d&#8217;une fonction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cette présentation permet de mettre en avant les éléments classiques que nous pouvons retrouver dans d&#8217;autres langages : Java, C, C++, Python, etc. et de mettre en avant les éléments plus spécifiques ou du moins originaux de Kotlin comme par exemple :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Les fonctions expressions</p>
</li>
<li>
<p>Les fonction génériques</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin s&#8217;inspire pour ne pas dire impose des éléments de la programmation "fonctionnelle". Les fonctions et procédures sont utilisées pour réduire le nombre d&#8217;instructions à rédiger en appliquant des fondements de la programmation fonctionnelle.</p>
</div>
</div>
<div class="sect3">
<h4 id="_en_tête_de_la_fonction"><a class="anchor" href="#_en_tête_de_la_fonction"></a>7.1.2. En-tête de la fonction</h4>
<div class="sect4">
<h5 id="_en_tête_de_base"><a class="anchor" href="#_en_tête_de_base"></a>En-tête de base</h5>
<div class="paragraph">
<p>L&#8217;en-tête contient les principales informations de la fonction :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identifiant;</p>
</li>
<li>
<p>Paramètres et types associés (éventuellement des valeurs par défaut);</p>
</li>
<li>
<p>Le type retourné par la fonction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Syntaxe de l&#8217;en-tête avec retour :</strong></p>
</div>
<div class="paragraph">
<p>L&#8217;en-tête commence par le mot clé <strong class="yellow">fun</strong>, suivi par les éventuels paramètres placés entre parenthèse et en fin de ligne l&#8217;éventuel type retourné.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe en-tête AVEC retour :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFonction(idArg01: typeArg01, idArg02: typeArg02, ...): typeRetour</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple de l&#8217;en-tête d&#8217;une fonction somme()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun somme(operandeGauche: Double, operandeDroit: Double): Double</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si la fonction ne retourne rien (procédure), alors on ne renseigne rien pour le type de retour.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe en-tête SANS retour :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFonction(idArg01: typeArg01, idArg02: typeArg02, ...)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple de l&#8217;en-tête d&#8217;une procédure</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun procedure(message: String)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
En réalité une procédure en Kotlin est une fonction qui retourne un type particulier <strong>Unit</strong>. Nous avons par besoin de spécifier dans l&#8217;en-tête le retour de type <strong>Unit</strong> le compilateur s&#8217;en charge à notre place. A ce stade on peut considérer que <strong>Unit</strong> est l&#8217;équivalent de <strong>void</strong> que nous pouvons retrouver dans d&#8217;autres langages comme Java.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_en_tête_avec_argument_par_défaut"><a class="anchor" href="#_en_tête_avec_argument_par_défaut"></a>En-tête avec argument par défaut</h5>
<div class="paragraph">
<p>Kotlin permet de fournir des valeurs par défaut pour l&#8217;initialisation des paramètres. Si un argument est donné pour le paramètre, alors l&#8217;argument fourni est utilisé pour initialiser le paramètre. Par contre en absence d&#8217;argument, c&#8217;est la valeur par défaut qui sera utilisée.</p>
</div>
<div class="paragraph">
<p>La syntaxe est très simple, il suffit d&#8217;indiquer la valeur par défaut au niveau de l&#8217;en-tête :</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;en-tête d&#8217;une fonction avec valeur</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFonction(idArg01: typeArg01 = valDefaut01: , idArg02: typeArg02 = valDefaut02, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>On peut naturellement mixer des paramètres avec et sans valeur par défaut.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de l&#8217;en-tête d&#8217;une fonction produit prenant 2 arguments :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun produit(x: Double = 2.0, y: Double = 4.0) : Double {</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_en_tête_avec_nombre_darguments_variable"><a class="anchor" href="#_en_tête_avec_nombre_darguments_variable"></a>En-tête avec nombre d&#8217;arguments variable :</h5>
<div class="paragraph">
<p>Il y a des situations où le nombre d&#8217;arguments qui sera fourni n&#8217;est pas connu à l&#8217;avance. Il est possible de définir des fonctions qui recevrons un nombre variable d&#8217;arguments.</p>
</div>
<div class="paragraph">
<p>La mise en oeuvre est assez aisée, il suffit d&#8217;utiliser le mot clé <strong class="red">vararg</strong></p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;en-tête d&#8217;une fonction avec un nombre variable d&#8217;arguments :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFonction(vararg idVar: typeArguments): typeRetour</code></pre>
</div>
</div>
<div class="paragraph">
<p>Prenons en exemple une fonction somme qui réalisera la somme des arguments fournis à l&#8217;appel de la fonction :</p>
</div>
<div class="listingblock">
<div class="title">Exemple de la fonction somme dont le nombre d&#8217;arguments est libre :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun somme(vararg termes: Double): Double</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_mutabilité_des_paramètres_dune_fonction"><a class="anchor" href="#_mutabilité_des_paramètres_dune_fonction"></a>Mutabilité des paramètres d&#8217;une fonction</h5>
<div class="paragraph">
<p>Nous pouvons constater que nous n&#8217;avons pas préciser dans les différentes en-têtes le status de "mutabilité" des paramètres de la fonction&#8230;&#8203; En Kotlin :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>les paramètres d&#8217;une fonction <strong>SONT TOUJOURS IMMUABLES</strong>;</p>
</li>
<li>
<p>Il n&#8217;est pas possible d&#8217;utiliser les modificateurs <strong class="red">val</strong> et <strong class="red">var</strong> sur les paramètres.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ce mode de comportement sur les paramètres d&#8217;une fonction permet de limiter les effets de bords, du moins pour des types simples. Pour des types structurés il sera toujours possible de modifier les valeurs de la structure de données si cette dernière n&#8217;a pas été initialisée comme immuable.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_corps_de_la_fonction"><a class="anchor" href="#_corps_de_la_fonction"></a>7.1.3. Corps de la fonction</h4>
<div class="sect4">
<h5 id="_corps_dune_fonction_de_base"><a class="anchor" href="#_corps_dune_fonction_de_base"></a>Corps d&#8217;une fonction de base</h5>
<div class="paragraph">
<p>Kotlin en prime abord utilise une forme conventionnelle pour la forme du corps des fonctions, on retrouve donc les éléments classiques :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Une accolade ouvrante <strong class="red">{</strong> pour marquer le début du bloc d&#8217;instructions et une accolade fermante <strong class="red">}</strong> pour signaler la fin du bloc d&#8217;instruction.</p>
</li>
<li>
<p>Le mot clé <strong class="red">return</strong> pour les éventuels retours. Si la fonction ne retourne rien, il suffit de ne rien indiquer.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Syntaxe :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFonction(idArg01: Type01 = valDefaut01, vararg idVar: typeArguments): typeRetour{
    // Corps de la fonction contenant l'ensemble des instructions.
    return varRetour</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun exemple(mot1: String = "Bonjour", vararg mots: String): String{
    var phrase: String = mot1
    for (mot in mots)
        phrase += " " + mot
    return phrase
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Appel de la fonction exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(exemple("Coucou", "comment", "allez-vous ?"))
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage dans la console :</div>
<div class="content">
<pre>Coucou comment allez-vous ?

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_les_fonctions_expressions"><a class="anchor" href="#_les_fonctions_expressions"></a>Les fonctions expressions</h5>
<div class="paragraph">
<p>Kotlin propose une alternative pour rédiger les corps des fonctions tout particulièrement quand le corps est constitué d&#8217;une seule ligne d&#8217;instruction. En effet, il ser alors possible de placer sur la même ligne l&#8217;en-tête suivi de l&#8217;expression réalisée par la fonction.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFoncExpression(arg01: Type01,...): TypeRetour = expression</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun produit(facteurGauche: Double, facteurDroit: Double): Double = facteurGauche * facteurDroit</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Appel :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(produit(3.0, 15.0))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_appel_des_fonctions"><a class="anchor" href="#_appel_des_fonctions"></a>7.1.4. Appel des fonctions</h4>
<div class="paragraph">
<p>Pas de difficultés particulière pour l&#8217;appel des fonctions. La formulation est classique, on utilise l&#8217;identifiant de la fonction et nous fournissons les arguments entre une paire de parenthèses.</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;appel d&#8217;une fonction :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun somme(operandeGauche: Double, operandeDroit: Double): Double{
    return operandeGauche + operandeDroit
}

fun main(){
    var resultat = somme(5.0, -2.0)
    println(resultat)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage console :</div>
<div class="content">
<pre>3.0

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;uilisation du nom des paramètres permet de passer les arguments dans n&#8217;importe quel ordre et sourtout de laisser les valeurs par défaut pour les arguments qui ne sont pas renseignés !</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;appel d&#8217;une fonction en utilisant le nom des paramètres :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun exemple(mot1: String = "Bonjour", vararg mots: String): String {
    var phrase: String = mot1
    for (mot in mots)
        phrase += " " + mot
    return phrase
}

fun main(){
    var retour = exemple(mots = arrayOf("tout", "le", "monde !"))
    println(retour)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Bonjour tout le monde !

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_fonctions_higher_order_functions_fonction_dordre_supérieur"><a class="anchor" href="#_les_fonctions_higher_order_functions_fonction_dordre_supérieur"></a>7.1.5. Les fonctions "Higher-order functions" (fonction d&#8217;ordre supérieur)</h4>
<div class="sect4">
<h5 id="_définition_dune_fonction_dordre_supérieur"><a class="anchor" href="#_définition_dune_fonction_dordre_supérieur"></a>Définition d&#8217;une fonction d&#8217;ordre supérieur</h5>
<div class="paragraph">
<p>Les <strong><em>Higher-order function</em></strong> que nous pouvons traduire comme "fonctions d&#8217;odre supérieur" sont des fonctions qui vont justement prendre en argument une fonction ou en retourner une.<br>
Ce sont donc des fonctions où l&#8217;on pourra passer des fonctions lambdas. Nous allons voir ici comment les construire.</p>
</div>
<div class="paragraph">
<p>Pour les définir nous aurons besoins de caractériser la fonction paramètre, pour ce faire nous utiliserons une paire de parenthèse <strong class="red">( )</strong> pour signaler que l&#8217;argument attendu est la référence d&#8217;une fonction. Nous devrons préciser les types des éventuels arguments de la fonction passé en argument à l&#8217;intérieur des parenthèses. On devra impérativement préciser le type retourné par la fonction donnée en argument. On utiliser le mot clé <strong class="red">Unit</strong> si la fonction ne retourne rien.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;une fonction d&#8217;ordre supérieur prenant en argument une fonction sans argument et sans retour :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFoncOrdreSup(argFonc: () -&gt; Unit): typeRetour{
    // Corps de la fonction...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;une fonction d&#8217;ordre supérieur prenant en argument une fonction sans argument mais avec retour :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFoncOrdreSup(argFonc: () -&gt; typeRetour): typeRetour{
    // Corps de la fonction...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;une fonction d&#8217;ordre supérieur prenant en argument une fonction avec argument et retour :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun idFoncOrdreSup(argFonc: (typeRetour) -&gt; typeRetour): typeRetour{
    // Corps de la fonction...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple de définition de 3 fonctions d&#8217;odre supérieur :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun fonctionOrdreSuperieur_01(argFonc: () -&gt; Unit){
    argFonc()
}

fun fonctionOrdreSuperieur_02(argFonc: () -&gt; String): String{
    return argFonc()
}

fun fonctionOrdreSuperieur_03(argFonc: (String) -&gt; String): String{
    return argFonc("Hello")
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_appel_dune_fonction_dordre_supérieur"><a class="anchor" href="#_appel_dune_fonction_dordre_supérieur"></a>Appel d&#8217;une fonction d&#8217;ordre supérieur</h5>
<div class="paragraph">
<p>Une fonction d&#8217;odre supérieur prendra en argument une fonction prédéfinie. Cette fonction peut être :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Une fonction lambda</strong> : nous expliquons dans la partie suivante la définition et l&#8217;utilisation d&#8217;une fonction lambda comme paramètre d&#8217;une fonction d&#8217;ordre supérieur.</p>
</li>
<li>
<p><strong>Une fonction régulière</strong> : Le passage de la référence comme argument requiert l&#8217;utilisation du symbole <strong class="red">::</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;appel d&#8217;une fonction d&#8217;ordre supérieur prenant une fonction régulière en argument :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">idFoncSuperieur(::idArgFonc)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition d'une fonction d'ordre supérieur :
fun cobaye(argFonc: (String) -&gt;String): String{
    return argFonc("Message original")
}
// Définition d'une fonction argument :
fun argument(mot: String): String = mot + " (Ok, message lu)"

fun main(){
    var retour: String
    retour = cobaye(::argument) // Le passage de la référence s'accompagne des ::
    println(retour)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage console :</div>
<div class="content">
<pre>Message original (Ok, message lu)

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_fonctions_lambdas_et_les_fonctions_anonymes"><a class="anchor" href="#_les_fonctions_lambdas_et_les_fonctions_anonymes"></a>7.1.6. Les fonctions lambdas et les fonctions anonymes :</h4>
<div class="sect4">
<h5 id="_les_lambdas"><a class="anchor" href="#_les_lambdas"></a>Les lambdas</h5>
<div class="paragraph">
<p>Pour rappel une fonction lambda est une fonction qui peut être définie et appelée sans identifiant. Typiquement l&#8217;instruction d&#8217;une fonction lambda sera utilisée dans un paramètre d&#8217;une autre fonction/méthode.<br>
Les lambdas permettent du gagner du temps en nous évitant de définir spécifiquement une fonction régulière qui ne sera utilisée qu&#8217;une seule fois ou très ponctuellement et dont le corps se réduit le plus souvent à une simple expression.</p>
</div>
<div class="paragraph">
<p>La syntaxe est la suivante :</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;une fonction lambda :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">{arg01: typeArg01, arg02: typeArg02, ...-&gt; expression}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemples :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Koltlin hljs" data-lang="Koltlin">fun main() {

    fonctionOrdreSuperieur_01({println("Appel de lambda_01")})
    println( fonctionOrdreSuperieur_02( {"Appel de lambda_02"} ) )
    println( fonctionOrdreSuperieur_03 ( { chaine: String -&gt;  chaine + " Fin !" } ) )
    // Utilisation d'une référence :
    val f = { chaine: String -&gt;  chaine + " Ok !" }
    println(  fonctionOrdreSuperieur_03(f))
}
// Définition des fonctions d'ordre supérieur
fun fonctionOrdreSuperieur_01(argFonc: () -&gt; Unit){
    argFonc()
}
fun fonctionOrdreSuperieur_02(argFonc: () -&gt; String): String{
    return argFonc()
}
fun fonctionOrdreSuperieur_03(argFonc: (String) -&gt; String): String{
    return argFonc("Exécution de la fonction d'ordre supérieur n°3")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat dans la console :</div>
<div class="content">
<pre>Appel de lambda_01
Appel de lambda_02
Exécution de la fonction d'ordre supérieur n°3 Fin !
Exécution de la fonction d'ordre supérieur n°3 Ok !

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Variante syntaxique :</strong></p>
</div>
<div class="paragraph">
<p>Si une fonction lambda est placée comme <strong>DERNIER (ou unique)</strong> paramètre d&#8217;une fonction d&#8217;ordre supérieur, il est alors possible de placer la fonction lambda <strong>JUSTE APRES</strong> la fonction d&#8217;ordre supérieur.</p>
</div>
<div class="listingblock">
<div class="title">Application sur l&#8217;exemple précédent :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    fonctionOrdreSuperieur_01() {println("Appel de lambda_01")}
    println( fonctionOrdreSuperieur_02() {"Appel de lambda_02"} )
    println( fonctionOrdreSuperieur_03 () { chaine: String -&gt;  chaine + " Fin !" } )</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_utilisation_du_paramètre_it"><a class="anchor" href="#_utilisation_du_paramètre_it"></a>Utilisation du paramètre it :</h5>
<div class="paragraph">
<p>Kotlin met à disposition un paramètre <strong class="red">it</strong> qui nous épargne de déclarer justement un paramètre dans une fonction lambda. Cela est possible seulement si la fonction lambda requiert un seul paramètre.</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;utilisation du paramètre it :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la fonction d'ordre supérieur :
fun doublerValeur(valeur: Double, lambda: (Double) -&gt; Double) {println("Le double de $valeur = ${lambda(valeur)}")}

fun main(){
    // Appels de la fonction d'ordre supérieur avec une fonction lambda :
    doublerValeur(16.0, {x: Double -&gt; 2 * x}) // Forme complète avec la déclaration du paramètre
    doublerValeur(16.0, {2 * it})              // Forme utilisant le paramètre it</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_les_fonctions_anonymes"><a class="anchor" href="#_les_fonctions_anonymes"></a>Les fonctions anonymes</h5>
<div class="paragraph">
<p>Les fonction anonymes sont au niveau de leur syntaxe et utilisation un mix entre les fonctions lambdas et les fonctions expressions.<br>
Outre la différence syntaxique, il y a également une différence à la compilation. Le type de retour n&#8217;est pas préciser pour une fonction lambda, c&#8217;est le compilateur qui met en oeuvre le mécanisme d&#8217;inférence pour fournir le type d&#8217;une fonction lambda. Dans une fonction anonyme nous pourrons préciser le type retourné.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxes d&#8217;une fonction anonyme :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Syntaxe sous forme d'expression :
val anoynyme01  = fun(arg01: Type01, arg02: Type02, ...): typeRetour = expression

// Syntaxe avec bloc d'instructions :
val anoynyme02  = fun(arg01: Type01, arg02: Type02, ...): typeRetour {// Bloc d'instructions avec return}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de 2 fonctions anonymes selon 2 variantes syntaxiques :
val somme01 = fun(x: Double, y: Double): Double {return x + y} // Cette variante peut s'écrire sur plusieurs lignes
val somme02 = fun(x: Double, y: Double): Double =  x + y // Doit s'écrire sur 1 ligne.

// Fonction d'ordre supérieur :
fun fonctionOrdreSup(x: Double, y: Double, somme: (Double, Double) -&gt; Double) = println("$x + $y = ${somme(x, y)}")

// Fonction principale :
fun main(){
    fonctionOrdreSup(5.0, 3.0, somme01)
    fonctionOrdreSup(-10.0, 7.0, somme02)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Console :</div>
<div class="content">
<pre>5.0 + 3.0 = 8.0
-10.0 + 7.0 = -3.0

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_visibilité_des_fonctions"><a class="anchor" href="#_visibilité_des_fonctions"></a>7.1.7. Visibilité des fonctions</h4>
<div class="paragraph">
<p>Par défaut toutes les fonctions sont visibles par tous. Pour rendre inaccessibles nos fonctions il faut de rajouter au début de leur en-tête le mot clé <strong>private</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe de l&#8217;en-tête d&#8217;une fonction privée :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">private fun idFonction(idArg01: typeArg01, idArg02: typeArg02, ...): typeRetour</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_le_smartcast_transtypage_intelligent"><a class="anchor" href="#_le_smartcast_transtypage_intelligent"></a>7.1.8. Le smartCast (transtypage intelligent)</h4>
<div class="sect4">
<h5 id="_illustration_du_besoin_de_transtypage"><a class="anchor" href="#_illustration_du_besoin_de_transtypage"></a>Illustration du besoin de transtypage :</h5>
<div class="paragraph">
<p>Avant de détailler les posibilités de transtypage intelligent de Kotlin, illustrons nos besoin avec la fonction <strong>somme()</strong> que nous avons vu en début :</p>
</div>
<div class="listingblock">
<div class="title">Fonction somme() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun somme(operandeGauche: Double, operandeDroit: Double): Double{
    return operandeGauche + operandeDroit
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette fonction est peu commode à l&#8217;usage car nous devons impérativement fournir 2 arguments de type <strong>Double</strong>. L&#8217;usage du type <strong>Int</strong> se solde par un échec !</p>
</div>
<div class="listingblock">
<div class="title">Appel de la fonction somme() avec 2 arguments du type Int</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main() {
    println(somme(2, 3))
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Erreur affichée :</div>
<div class="content">
<pre>Kotlin: The integer literal does not conform to the expected type Double</pre>
</div>
</div>
<div class="paragraph">
<p>Pour donner plus de souplesse, nous allons modifier le type des paramètres de la fonction <strong>somme()</strong>. Nous allons utiliser le type <strong>Number</strong>. En effet avec le système d&#8217;héritage, touts les types numériques (Float, Double, etc&#8230;&#8203;) de Kotlin héritent du type <strong>Number</strong>.</p>
</div>
<div class="paragraph">
<p>Par contre la somme de deux variables du type <strong>Number</strong> n&#8217;est pas autorisée. Il faut donc procéder à un transtypage vers le type <strong>Double</strong> par exemple pour pouvoir réaliser la somme.</p>
</div>
<div class="listingblock">
<div class="title">Solution :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">private fun somme(operandeGauche: Number, operandeDroit: Number): Double{
    return operandeGauche.toDouble() + operandeDroit.toDouble()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_test_dun_type_et_smartcast_avec_is"><a class="anchor" href="#_test_dun_type_et_smartcast_avec_is"></a>Test d&#8217;un type et smartCast avec is</h5>
<div class="paragraph">
<p>Nous serons mener à déterminer le type d&#8217;un objet afin d&#8217;agir en conséquence. Le mot clé <strong class="red">is</strong> nous permet de tester le type d&#8217;une donnée. Illustons cela avec l&#8217;exemple suivant :
La fonction <strong>taille(Any)</strong> ci-dessous prend en argument un objet et retourne sa taille si l&#8217;objet est une <strong>Collection</strong> (<strong>List</strong>, <strong>Set</strong> ou <strong>Map</strong>) ou une chaîne de caractères <strong>String</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de l&#8217;utilisation de <strong>is</strong> :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun taille(argObj: Any): Int{
    if (argObj is Collection&lt;*&gt;) return argObj.size
    if (argObj is String) return  argObj.length
    return 0
}

fun main(){
    val listeTest = listOf(0, 1 ,2, 3)
    val setTest = setOf(4, 5, 6)
    val texte = "Kotlin"

    println("Taille de listeTest : ${taille(listeTest)}")
    println("Taille de setTest : ${taille(setTest)}")
    println("Taille de texte : ${taille(texte)}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage console :</div>
<div class="content">
<pre>Taille de listeTest : 4
Taille de setTest : 3
Taille de texte : 6

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>On parle <strong>smartCast</strong> car dans d&#8217;autres langages la ligne suivante : <span class="blue">if (argObj is String) return  argObj.length</span> aurait dû s&#8217;écrire <span class="blue">if (argObj is String) return  argObj.<strong>toString()</strong>.length</span>
Ici c&#8217;est Kotlin qui a pris en charge la transtypage après l&#8217;utilisation de <strong>is</strong>.</p>
</div>
<div class="paragraph">
<p>Le code reste tout de même un poil rébarbatif avec l&#8217;utilisation du <strong class="red">if</strong>, on est succeptible de conduire un certain nombre de tests suivant les types visés. Une structure/expression avec <strong class="red">when</strong> devrait être plus optimal&#8230;&#8203; Et c&#8217;est la cas, voici ce que cela donne :</p>
</div>
<div class="listingblock">
<div class="title">Amélioration du code, utilisation conjointe du <strong>is</strong> avec <strong>when</strong> :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun taille(argObj: Any) = when(argObj){
    is Collection&lt;*&gt; -&gt; argObj.size
    is String -&gt; argObj.length
    else -&gt; 0
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_transtypage_avec_as"><a class="anchor" href="#_transtypage_avec_as"></a>Transtypage avec as</h5>
<div class="paragraph">
<p>Avec <strong class="red">is</strong> nous procédions à un test et à une conversion à la volée en cas de succès d&#8217;appartenance au type ciblé.
Avec <strong class="red">as</strong> l&#8217;approche est différente, nous allons procéder à une conversion sans procéder à un test préalable.
Mais attention il faut que le type de destination soit cohérent</p>
</div>
<div class="listingblock">
<div class="title">Exemples sur l&#8217;instruction as :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    var y: Number = 3L // La constante affectée est un Long
    var z: Long = y as Long

    var k: Number = 3 // La constante affectée est un Int
    var l: Int = k as Int

    var bidule: Any = "Kotlin" // La constante affectée est un String
    var texte: String = bidule as String</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_fonctions_génériques"><a class="anchor" href="#_les_fonctions_génériques"></a>7.1.9. Les fonctions génériques</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_la_p_o_o_programmation_orientée_objet"><a class="anchor" href="#_la_p_o_o_programmation_orientée_objet"></a>8. La P.O.O. (Programmation Orientée Objet)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_les_classes"><a class="anchor" href="#_les_classes"></a>8.1. Les classes</h3>
<div class="sect3">
<h4 id="_généralités"><a class="anchor" href="#_généralités"></a>8.1.1. Généralités</h4>
<div class="paragraph">
<p>Les classes en Kotlin disposent d&#8217;un constructeur dit primaire dont la syntaxe à la particularité d&#8217;être intégré dans l&#8217;en-tête de la classe. Cette manière de faire permet de faciliter la déclaration des attributs. Les accesseurs (getters) et mutateurs (setters) sont par ailleurs générés automatiquement. D&#8217;autres constructeurs dits secondaires peuvent également être déclarés. C&#8217;est leur signature (nombre et types des arguments) qui permet de sélectionner le constructeur idoine pour la phase d&#8217;instanciation.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Tableau des modificateurs de visibilités :</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MODIFICATEUR</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>VISIBILITE</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">public</strong> (ou rien)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#8217;est le status de visibilité par défaut si aucun modificateur n&#8217;est spécifié. La propriété ou fonction est visible de tous.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">private</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">La propriété ou fonction n&#8217;est visible qu&#8217;au niveau de la classe.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">protected</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Propriété ou fonction visible uniquement dans la classe et ses sous classes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">internal</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Propriété ou fonction visible par tous les éléments du module.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_définition_déclaration_et_instanciation_dune_classe"><a class="anchor" href="#_définition_déclaration_et_instanciation_dune_classe"></a>8.1.2. Définition, déclaration et instanciation d&#8217;une classe</h4>
<div class="ulist">
<ul>
<li>
<p>La définition d&#8217;une classe se réalise avec le mot clé <strong class="red">class</strong>.</p>
</li>
<li>
<p>L&#8217;instruction de déclaration est classique étant donné qu&#8217;en Kotlin tous les types sont déjà des classes.</p>
</li>
<li>
<p>L&#8217;instanciation d&#8217;une classe se fait tout simplement en procédant à l&#8217;appel du constructeur de la classe.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>C&#8217;est le retour du constructeur qui permet d&#8217;associer la référence de l&#8217;objet fraîchement instancié à l&#8217;identifiant (déclaré préalablement ou à la volée en même temps que l&#8217;instanciation).</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe d&#8217;une classe vide</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">---
class IdClasse
---</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_vide-002f4c2a67900c71ea13ceb0f6efe16087961449.png" alt="Classe vide :">
</div>
<div class="title">Figure 1. Classe vide :</div>
</div>
<div class="listingblock">
<div class="title">Syntaxe pour la déclaration et/ou initialisation d&#8217;un objet :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    // Déclaration simple :
    val objIdClass: IdClasse

    // Instanciation de la classe après déclaration
    objIdClass = IdClasse()

    // Déclaration &amp; instanciation combinées :
    val instanceIdClasse = IdClasse()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_définition_du_constructeur_primaire_dune_classe"><a class="anchor" href="#_définition_du_constructeur_primaire_dune_classe"></a>8.1.3. Définition du constructeur primaire d&#8217;une classe</h4>
<div class="sect4">
<h5 id="_philosophie_dapproche_de_la_poo_avec_kotlin"><a class="anchor" href="#_philosophie_dapproche_de_la_poo_avec_kotlin"></a>Philosophie d&#8217;approche de la POO avec Kotlin</h5>
<div class="paragraph">
<p>Les classes acceptent des constructeurs secondaires grâce à la surcharge des méthodes. Cependant il préférable quand c&#8217;est possible d&#8217;utiliser les paramètres par défaut au niveau des paramètres du constructeur principal.</p>
</div>
</div>
<div class="sect4">
<h5 id="_le_constructeur_primaire"><a class="anchor" href="#_le_constructeur_primaire"></a>Le constructeur primaire</h5>
<div class="paragraph">
<p>En Kotlin le constructeur primaire est associé à l&#8217;en-tête de la classe. Le corps du constructeur est optionnel, il correspond à un bloc d&#8217;instructions identifié par le nom <strong class="red">init</strong>.<br>
Pour rappel l&#8217;objectif premier du constructeur est de déclarer et d&#8217;initialiser les attributs de l&#8217;objet instancié.</p>
</div>
<div class="paragraph">
<p>Nous allons mettre en place dans cette partie une classe <strong>Cercle</strong>. Puis nous allons faire évoluer cette classe afin de voir tous les éléments associés au constructeur primaire :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Etape 1 :</strong> Déclaration des attributs à partir de l&#8217;en-tête du constructeur principal;</p>
</li>
<li>
<p><strong>Etape 2 :</strong> Appel d&#8217;une méthode privée à partir du corps du constructeur principal;</p>
</li>
<li>
<p><strong>Etape 3 :</strong> Personnalisation des <em>getters</em> (accesseurs) et <em>setters</em> (mutateurs) des attributs.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 1. Caractéristiques (attributs) d&#8217;un objet cercle :</div>
<div class="content">
<div class="paragraph">
<p>Nous devons définir la localisation et la dimension du cercle :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La localisation est assurée par les coordonnées du centre : <strong>coordCentreX</strong> et <strong>coordCentreY</strong></p>
</li>
<li>
<p>La dimension est définie par le <strong>rayon</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Des caractéristiques secondaires nous intéressent également :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Le périmètre</strong></p>
</li>
<li>
<p><strong>La surface</strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_Cercle_v0-59d83ccb92db62f83f32fd053adaedcdf3c36678.png" alt="Classe Cercle :">
</div>
<div class="title">Figure 2. Classe Cercle :</div>
</div>
<div class="paragraph">
<p><strong class="underline">Etape 1 :</strong> Création de la classe et de l&#8217;en-tête du construction principal</p>
</div>
<div class="listingblock">
<div class="title"><strong>Etape 1 :</strong> Création de la classe <strong>Cercle</strong> avec déclaration des attributs à partir de l&#8217;en-tête du constructeur principal.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Koltin hljs" data-lang="Koltin">class Cercle(val coordCentreX: Number = 0, val coordCentreY:Number = 0, val rayon: Number)</code></pre>
</div>
</div>
<div class="paragraph">
<p>En une seule ligne nous avons défini notre classe ! Avec Kotlin il n&#8217;est pas forcement nécessaire de définir dans le corps de la classe les attributs et de les initialiser avec les arguments fournis au constructeur. Nous serons menés à le faire sur l&#8217;étape 3 afin de personnaliser les <em>getters</em> (accesseurs) et <em>setters</em> (mutateurs).</p>
</div>
<div class="paragraph">
<p>La création des <em>getters/setters</em> est liée aux mots clés <strong class="red">var</strong> et <strong class="red">val</strong> des identifiants (<strong>coordCentreX</strong>; <strong>coordCentreY</strong> et <strong>rayon</strong>) :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Absence</strong> de <strong class="red">val</strong> ou <strong class="red">var</strong>  : L&#8217;identifiant est un simple paramètre/argument, aucun attribut ne sera généré.</p>
</li>
<li>
<p><strong class="red">val</strong> ou <strong class="red">var</strong> associé à l&#8217;identificateur :</p>
<div class="ulist">
<ul>
<li>
<p><strong class="red">val</strong> ou <strong class="red">public val</strong> : Création d&#8217;un attribut et de son getter (accesseur). L&#8217;accès en modification n&#8217;est pas autorisé.</p>
</li>
<li>
<p><strong class="red">var</strong> ou <strong class="red">public var</strong> : Création d&#8217;un attribut avec son getter (accesseur) et setter (mutateur).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong class="red">private val</strong> ou <strong class="red">var</strong> : Création d&#8217;un attribut privé accessible uniquement au code de la classe en lecture.</p>
</li>
<li>
<p><strong class="red">protected val</strong> ou <strong class="red">var</strong>  : Création d&#8217;un attribut avec accès au code de sa classe et des sous-classes.</p>
</li>
<li>
<p><strong class="red">internal val</strong> ou <strong class="red">var</strong> : Création d&#8217;une attribut visible uniquement par le code du même package.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Procédons à des essais sur notre classe <strong>Cercle</strong>.<br>
Pour ce faire :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modifions temporairement l&#8217;attribut <strong>rayon</strong> en le rendant <strong>private</strong>;</p>
</li>
<li>
<p>Instancions un objet <strong>objCercle</strong></p>
</li>
<li>
<p>Accédons aux attributs <strong>coordCentreX</strong> et <strong>coordCentreY</strong>;</p>
</li>
<li>
<p>Constatons qu&#8217;une tentative d&#8217;accès à l&#8217;attribut <strong>rayon</strong> se solde par une erreur (action du modificateur <strong>private</strong>);</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Test de la classe <strong>Cercle</strong> :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Cercle(val coordCentreX: Number = 0, val coordCentreY:Number = 0, private val rayon: Number)

fun main(){
    val objCercle = Cercle(rayon = 1)
    println("Coordonnées centre : (${objCercle.coordCentreX}, ${objCercle.coordCentreY})")
    println("Rayon :${objCercle.rayon}")

    println(objCercle.rayon)        // Echec, attribut privé
    objCercle.coordCentreX = 1      // Echec, accès en lecture
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong class="underline">Etape 2 :</strong> Ajout d&#8217;une méthode privée pour le calcul du périmètre et de la surface</p>
</div>
<div class="paragraph">
<p>Remettons l&#8217;en-tête dans sa forme initiale :</p>
</div>
<div class="listingblock">
<div class="title">*Reformulation de l&#8217;en-tête à sa forme initiale :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Koltin hljs" data-lang="Koltin">class Cercle(val coordCentreX: Number = 0, val coordCentreY:Number = 0, val rayon: Number)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Nous allons ajouter 3 éléments :</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Déclaration des attributs suivants :</p>
<div class="ulist">
<ul>
<li>
<p><strong>perimetre</strong></p>
</li>
<li>
<p><strong>surface</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>2 méthodes privées :</p>
<div class="ulist">
<ul>
<li>
<p><strong>calculerPerimetre()</strong></p>
</li>
<li>
<p><strong>calculerSurface()</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Appel des méthodes par le constructeur primaire des méthodes :</p>
<div class="ulist">
<ul>
<li>
<p><strong>calculerPerimetre()</strong></p>
</li>
<li>
<p><strong>calculerSurface</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_Cercle_v1-5ec7436f496c6f84cdb1343789359a726157ec4a.png" alt="Classe Cercle :">
</div>
<div class="title">Figure 3. Classe Cercle :</div>
</div>
<div class="paragraph">
<p>En préalable, rajouter l&#8217;import de la constante <strong>PI</strong> et la méthode <strong>pow</strong> en rajoutant les instructions suivantes :</p>
</div>
<div class="listingblock">
<div class="title">Import de PI et pow :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">import kotlin.math.pow
import kotlin.math.PI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Voici ce que cela donne pour notre classe.</p>
</div>
<div class="listingblock">
<div class="title"><strong>Etape 2 :</strong> Ajout des attributs, méthodes et du corps du constructeur principal</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Cercle(val coordCentreX: Number = 0, val coordCentreY: Number = 0, val rayon: Number){

    // Attributs :
    var perimetre: Double = 0.0
    var surface: Double = 0.0

    // Méthodes :
    private fun calculerPerimetre(){perimetre = 2 * PI * rayon.toDouble()}
    private fun calculerSurface(){surface = PI * rayon.toDouble().pow(2)}

    // Corps du constructeur principal :
    init{
        calculerPerimetre()
        calculerSurface()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nous pouvons vérifier le comportement de notre classe :</p>
</div>
<div class="listingblock">
<div class="title">Fonction main() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">    val objCercle = Cercle(rayon = 1)
    println("Coordonnées centre : (${objCercle.coordCentreX}, ${objCercle.coordCentreY})")
    println("Rayon : ${objCercle.rayon}")
    println("Périmètre : ${objCercle.perimetre}")
    println("Surface : ${objCercle.surface}")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat dans la console :</div>
<div class="content">
<pre>Coordonnées centre : (0, 0)
Rayon : 1
Périmètre : 6.283185307179586
Surface : 3.141592653589793

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong class="underline">Etape 3 :</strong> Personnalisation des getters et setters</p>
</div>
<div class="paragraph">
<p>Nous vous proposons d&#8217;implémenter des setters pour les attributs :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>coordCentreX</strong></p>
</li>
<li>
<p><strong>coordCentreY</strong></p>
</li>
<li>
<p><strong>rayon</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pour <strong>coordCentreX</strong> et <strong>coordCentreY</strong> cela se fait très simplement, il suffit de remplacer <strong class="red">val</strong> par <strong class="red">var</strong> et le tour est joué.
Par contre pour l&#8217;attribut <strong>rayon</strong> cela n&#8217;est pas suffisant&#8230;&#8203; En effet le problème est le suivant, modifier le rayon du cercle implique également un changement des attributs <strong>perimetre</strong> et <strong>surface</strong>.<br>
Pour mettre à jour les attributs <strong>perimetre</strong> et <strong>surface</strong> il suffit de refaire un appel des méthodes privées <strong>calculerPerimetre</strong> et <strong>calculerSurface</strong>. Sauf que durant l&#8217;instanciation c&#8217;était le constructeur primaire qui assurait ce rôle. Le plus simple en cas de modification de l&#8217;attribut <strong>rayon</strong> est de demander au setters de <strong>rayon</strong> d&#8217;appeler cette méthode !</p>
</div>
<div class="paragraph">
<p>Procédons donc aux modifications suivantes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Passage de <strong class="red">val</strong> à <strong class="red">var</strong> pour les attributs <strong>coordCentreX</strong> et <strong>coordCentreY</strong>.</p>
</li>
<li>
<p>Suppression de <strong class="red">val</strong> pour <strong>rayon</strong>, à ce moment <strong>rayon</strong> dans l&#8217;en-tête du constructeur principal <strong>N&#8217;EST PLUS UN ATTRIBUT</strong> mais un simple <strong>PARAMETRE</strong>.</p>
</li>
<li>
<p>Ajout de la déclaration de l&#8217;attribut <strong>rayon</strong> dans le corps de classe.</p>
</li>
<li>
<p>Initialisation de l&#8217;attribut <strong>rayon</strong> avec le paramètre associé <strong>rayon</strong>.</p>
</li>
<li>
<p>Personnalisation du getter de <strong>rayon</strong>, on affichera un simple message dans la console, cela est juste un prétexte ici pour montrer comment nous pouvons personnaliser un getter.</p>
</li>
<li>
<p>Personnalisation du setter de <strong>rayon</strong> afin qu&#8217;il procède à l&#8217;appel des méthodes : <strong>calculerRayon</strong> et <strong>calculerPerimetre</strong>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Etape 3 : Finalisation de la classe Cercle :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Cercle(var coordCentreX: Number = 0, var coordCentreY:Number = 0, rayon: Number){

    // Attributs :
    var perimetre: Double = 0.0
    var surface: Double = 0.0
    var rayon: Number = 0
        get() {
            println("Exécution du getter du rayon !")
            return field    // field est l'attribut, ici rayon
        }
        set(valUpDate) {
            field = valUpDate
            calculerPerimetre()
            calculerSurface()
        }

    // Méthodes :
    private fun calculerPerimetre(){perimetre = 2 * PI * rayon.toDouble()}
    private fun calculerSurface(){surface = PI * rayon.toDouble().pow(2)}

    // Corps du constructeur principal :
    init{
        this.rayon = rayon      // Initialisation de l'attribut à partir du paramètre du constructeur principal
        calculerPerimetre()
        calculerSurface()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On rajoute un appel au setter de rayon pour modifier sa valeur.</p>
</div>
<div class="listingblock">
<div class="title">Code de démontration :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    val objCercle = Cercle(rayon = 1)
    objCercle.rayon = 2.0
    println("Coordonnées centre : (${objCercle.coordCentreX}, ${objCercle.coordCentreY})")
    println("Rayon : ${objCercle.rayon}")
    println("Périmètre : ${objCercle.perimetre}")
    println("Surface : ${objCercle.surface}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Exécution du getter du rayon !
Exécution du getter du rayon !
Exécution du getter du rayon !
Exécution du getter du rayon !
Exécution du getter du rayon !
Exécution du getter du rayon !
Coordonnées centre : (0, 0)
Exécution du getter du rayon !
Rayon : 2.0
Périmètre : 12.566370614359172
Surface : 12.566370614359172

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_constructeurs_secondaires"><a class="anchor" href="#_les_constructeurs_secondaires"></a>8.1.4. Les constructeurs secondaires</h4>
<div class="sect4">
<h5 id="_avant_propos_3"><a class="anchor" href="#_avant_propos_3"></a>Avant propos</h5>
<div class="paragraph">
<p>Avant d&#8217;aborder l&#8217;héritage, nous allons étudier le fonctionnement des constructeurs secondaires dans une classe de base (sans héritage).</p>
</div>
</div>
<div class="sect4">
<h5 id="_ordre_dappel_des_constructeurs"><a class="anchor" href="#_ordre_dappel_des_constructeurs"></a>Ordre d&#8217;appel des constructeurs</h5>
<div class="paragraph">
<p>Le constructeur primaire qu&#8217;il soit défini ou pas est <strong>TOUJOURS</strong> appelé. Même si la signature utilisée pour l&#8217;instanciation cible un constructeur secondaire, ce dernier devra obligatoirement appeler le constructeur primaire (on utilisera le mot clé <strong class="red">this</strong>)</p>
</div>
<div class="paragraph">
<p><strong>Voici quelques exemples illustrant notre propos :</strong></p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_constructeur_second-0267244ab502e0524ffcb4aad2f245f8bea82afd.png" alt="Classe avec 1 constructeur secondaire :">
</div>
<div class="title">Figure 4. Classe avec 1 constructeur secondaire :</div>
</div>
<div class="listingblock">
<div class="title">Constructeur primaire non défini :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Exemple01{
    init {
        println("Constructeur primaire")
    }
    constructor(){
        println("Constructeur secondaire")
    }
}

fun main(){
    val obj01 = Exemple01()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage de la console : L&#8217;affichage de "Constructeur primaire" témoigne de l&#8217;éxecution du corps du constructeur primaire</div>
<div class="content">
<pre>Constructeur primaire
Constructeur secondaire

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Dans Exemple01 le constructeur primaire n&#8217;est pas explicitement défini, le mot clé dans ce cas exceptionnel n&#8217;est pas obligatoire pour le constructeur secondaire. Cependant nous constatons que bloc <strong>init</strong> du constructeur primaire est bien appelé.</p>
</div>
<div class="paragraph">
<p>Définissons le constructeur primaire (ajout d&#8217;une paire de parenthèses) et distingons la signature du constructeur secondaire en lui ajoutant un paramètre.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_constructeur_second_v2-f5394f9e57b3371c1c9a596f129c3ff38e533ced.png" alt="Classe avec 1 constructeur secondaire :">
</div>
<div class="title">Figure 5. Classe avec 1 constructeur secondaire :</div>
</div>
<div class="listingblock">
<div class="title">Constructeur primaire défini : L&#8217;ajout de la paire de parenthèse  marque la définition du constructeur primaire.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Exemple02(){
    init {
        println("Constructeur primaire")
    }
    constructor(bourage: Int): this(){
        println("Constructeur secondaire")
    }
}

fun main(){
    val obj01 = Exemple02(0)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Affichage de la console:</div>
<div class="content">
<pre>Constructeur primaire
Constructeur secondaire

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong class="underline">Commentaires :</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Le paramètre bourage du constructeur secondaire nous permet pour notre exemple de distinguer la signature  du constructeur secondaire de celle du constructeur primaire.</p>
</li>
<li>
<p>Le mot clé <strong class="red">this</strong> est ici <strong>OBLIGATOIRE</strong> à partir du moment que le constructeur primaire est défini pour permettre son appel tout en lui transmettant d&#8217;éventuels arguments.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_structure_dune_classe_avec_constructeurs_secondaires"><a class="anchor" href="#_structure_dune_classe_avec_constructeurs_secondaires"></a>8.1.5. Structure d&#8217;une classe avec constructeurs secondaires</h4>
<div class="paragraph">
<p>Nous vous proposons ici un exemple de classe avec des constructeurs secondaires.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_constructeur_second_v3-af30f699e0b25e9c660810963109820e7f15a0ad.png" alt="Classe avec 2 constructeurs secondaires :">
</div>
<div class="title">Figure 6. Classe avec 2 constructeurs secondaires :</div>
</div>
<div class="listingblock">
<div class="title">Classe complète :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Exemple03(){
    // Attributs :
    // (Tous les attributs sont déclarés avec var pour pouvoir
    // les initialiser avec les constructeurs secondaires)
    var attrib01: Int = 1
        private set // On rend la modification impossible
    var attrib02: Int = 2
    var attrib03: Int = 3

    init{
        println("constructeur primaire")
    }
    // Constructeurs secondaires :
    constructor( attrib01: Int ): this(){
        this.attrib01 = attrib01
        println("constructeur 01")
    }
    constructor( attrib02: Int, attrib03: Int ): this() {
        this.attrib02 = attrib02
        this.attrib03 = attrib03
        println("constructeur 02")
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat dans la console :</div>
<div class="content">
<pre>constructeur primaire
attrib01 = 1
constructeur primaire
constructeur 01
attrib01 = 5
constructeur primaire
constructeur 02
attrib02 = 20 et attrib03 = 30

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;utilisation de <strong class="red">val</strong> n&#8217;est pas possible car à ce moment la valeur n&#8217;acceptera pas de changement à partir du constructeur secoondaire.
La combinaison des mots clés <strong class="red">private set</strong> permettent de d&#8217;interdire la modification des valeurs par le "getteur".</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_les_attributs_méthodes_de_classe_les_objets_compagnons"><a class="anchor" href="#_les_attributs_méthodes_de_classe_les_objets_compagnons"></a>8.2. Les attributs &amp; méthodes de classe (Les objets compagnons)</h3>
<div class="paragraph">
<p>Dans des langages purement orientés objets comme Java nous somme obligés de déclarer des méthodes statiques pour accéder à la méthode sans passer par une instance de la classe définissant la méthode.<br>
Ce type de méthodes accessiblent directement d&#8217;une classe sont communément désignées des <strong>méthodes de classe</strong>.<br>
Il peut également être intéressant que des instances d&#8217;une classe puissent partager des attributs ayant des valeurs communes à tous les objets, c&#8217;est ce que l&#8217;on appelle des <strong>attributs de classe</strong>.</p>
</div>
<div class="paragraph">
<p>En Kotlin il est possible d&#8217;obtenir ce genre de comportement de la part d&#8217;attributs et de méthodes.
Cependant le moyen pour y parvenir diffère de ce que nous trouvons habituellement dans d&#8217;autres langages.
En effet Kotlin va utiliser des objets dits <strong>compagnon</strong> pour implémenter les attributs et méthodes de classe.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_elmtStatiques_v1-7bc98da6cc548c942251985ebbbf25b456037d0b.png" alt="Classe avec éléments statiques :">
</div>
<div class="title">Figure 7. Classe avec éléments statiques :</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;implémentation d&#8217;attributs et de méthodes de classe :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Math(){
    init{compteur += 1}

    companion object{
        // Définition d'un attribut de classe constant :
        val PI = 3.1415927
        // Définition d'un attribut mutable :
        var compteur = 0
        // Définition d'une méthode de classe :
        fun puissance2(x: Double) = x*x
    }
}

fun main(){
    println("Le nombre PI : ${Math.PI}")
    println("4 puissance 2 : ${Math.puissance2(4.0)}")
    val obj01 = Math()
    val Obj02 = Math()
    println("Nombre d'instances de la classe Math : ${Math.compteur}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Le nombre PI : 3.1415927
4 puissance 2 : 16.0
Nombre d'instances de la classe Math : 2

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lhéritage"><a class="anchor" href="#_lhéritage"></a>8.3. L&#8217;héritage</h3>
<div class="sect3">
<h4 id="_principes_de_base_de_lhéritage_en_kotlin"><a class="anchor" href="#_principes_de_base_de_lhéritage_en_kotlin"></a>8.3.1. Principes de base de l&#8217;héritage en Kotlin</h4>
<div class="paragraph">
<p>L&#8217;héritage est un concept puissant notamment pour factoriser du code. Cependant cela peut égalementconduire à des dérives. En effet des sous-classes (classes filles) peuvent avec le mot clé <strong class="red">override</strong> redéfinir des méthodes de la classe parente. Or cette redéfinition n&#8217;est pas forcément cohérente ou ne respecte pas les comportements initialement attendus. Cela est en contradiction avec les principes de la POO. Ainsi il est conseillé de <strong>fermer</strong> à l&#8217;héritage des classes qui ne sont pas pensées pour cet objectif.</p>
</div>
<div class="paragraph">
<p>En Kotlin la statégie avec l&#8217;héritage est en opposition avec celle de Java. En effet, en Java par défaut toutes les classes et leurs méthodes sont <strong>ouvertes</strong> à l&#8217;héritage. En Kotlin c&#8217;est l&#8217;inverse, les classes et méthodes sont <strong>fermées</strong> à l&#8217;héritage par défaut !</p>
</div>
</div>
<div class="sect3">
<h4 id="_ouvrir_une_classe_à_lhéritage"><a class="anchor" href="#_ouvrir_une_classe_à_lhéritage"></a>8.3.2. Ouvrir une classe à l&#8217;héritage</h4>
<div class="paragraph">
<p>Comme expliqué précédement, par défaut il n&#8217;est pas possible d&#8217;utiliser l&#8217;héritage sur une classe ne le permettant pas. Il faut que la classe l&#8217;autorise explicitement avec le mot clé <strong class="red">open</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Syntaxe pour ouvrir une classe à l&#8217;héritage :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">open class IdClasse(paramètres &amp; attributs du constructeur...) {
    // Corps de la classe
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Liste des modificateurs d&#8217;accès des classes :</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MODIFICATEUR ACCES</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ROLE</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">final</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elément (classe, méthode ou propriété) ne pouvant pas être redéfini par l&#8217;héritage. C&#8217;est l'<strong>état par défaut</strong> de tous les éléments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">open</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elément accessible par l&#8217;héritage et <strong>POUVANT</strong> être redéfini.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">abstract</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elément <strong>DEVANT</strong> être redéfini. Utilisable unique pour les classes abstraites.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="red">override</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Précède tout élément redéfini dans une classe enfant.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_héritage_dune_classe_de_base_vers_une_classe_dérivée"><a class="anchor" href="#_héritage_dune_classe_de_base_vers_une_classe_dérivée"></a>8.3.3. Héritage d&#8217;une classe de base vers une classe dérivée</h4>
<div class="sect4">
<h5 id="_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_sans_arguments"><a class="anchor" href="#_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_sans_arguments"></a>Mise en relation d&#8217;une classe dérivée avec une classe de base ayant un constructeur SANS arguments</h5>
<div class="paragraph">
<p>L&#8217;instruction est simple à mettre en oeuvre, la classe dérivée aura dans son en-tête un lien avec la classe de base (classe mère) en faisaint appel au construteur de la classe mère :</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v1-6948241f9c2998a8708142f5709bf25f4dd25123.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 8. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Instructions élémentaires pour l&#8217;héritage entre une classe dérivée et sa classe de base :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe de base :
open class Base(){
    // Corps de la classe Base
}

// Définition de la classe dérivée :
class Derive(): Base(){
    // Corps de la classe Derive
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_avec_arguments"><a class="anchor" href="#_mise_en_relation_dune_classe_dérivée_avec_une_classe_de_base_ayant_un_constructeur_avec_arguments"></a>8.3.4. Mise en relation d&#8217;une classe dérivée avec une classe de base ayant un constructeur AVEC arguments</h4>
<div class="paragraph">
<p>Notre exemple précédent était très basique car le constructeur de la classe de base ne prennait aucun argument. Cela nous permettait de mettre en avant le principe de mise en relation d&#8217;une classe de base avec sa classe dérivée.</p>
</div>
<div class="paragraph">
<p>Si le constructeur de la classe de base comporte des paramètres, il faut alors impérativement fournir des arguments à l&#8217;appel du constructeur de la classe de base dans l&#8217;en-tête de la classe dérivée.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v2-8b90363917b6cfa09d3ce5bf17e05d5757b3b4e4.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 9. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Instructions de passage des arguments de la classe dérivée vers sa classe de base :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe de base :
open class Base(var attrib01: Int, val attrib02: Int){}

// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int): Base(arg01, arg02){}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Il faut bien remarquer que les 2 paramètres du constructeur primaire de la classe <strong>Base</strong> vont générer 2 attributs (les paramètres sont accompagnés des mots clés <strong class="red">var</strong> et <strong class="red">val</strong>).
Le constructeur de la classe <strong>Derive</strong> comporte 2 paramètres qui seront transmis en argument dans l&#8217;appel du constructeur <strong>Base()</strong> de la classe de <strong>Base</strong>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_enrichissement_dune_classe_dérivée_ajout_dattributs_et_de_méthodes"><a class="anchor" href="#_enrichissement_dune_classe_dérivée_ajout_dattributs_et_de_méthodes"></a>8.3.5. Enrichissement d&#8217;une classe dérivée : Ajout d&#8217;attributs et de méthodes</h4>
<div class="paragraph">
<p>Sans ajout d&#8217;attributs et/ou de méthodes à une classe dérivée, l&#8217;héritage n&#8217;a aucun intérêt. Il n&#8217;y a pas de difficultés particulières, il suffit de déclarer nos méthodes et attributs dans la classe dérivée exactement comme nous pourrions le faire dans une classe de base.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v3-853aa61b80b8c896438bdb67bb6a0622082765d5.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 10. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Exemples illustrant les instructions pour ajouter des méthodes et attributs à la classe dérivée :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe de base :
open class Base(var attrib01: Int, val attrib02: Int){
    var attrib04: Int = 4
    init{
        println("Constructeur primaire de Base")
    }
    fun methode01(){
        println("Méthode01 de Base")
    }
}

// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int, val attrib03: Int): Base(arg01, arg02){
    init{
        println("Constructeur primaire de Derive")
        println("attrib01 : ${attrib01}\nattrib02 : ${attrib02}\nattrib03 : ${attrib03}")
    }
    fun methode02(){
        println("Méthode02 de Derive")
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat dans la console :</div>
<div class="content">
<pre>Constructeur primaire de Base
Constructeur primaire de Derive
attrib01 : 1
attrib02 : 2
attrib03 : 3
Attrib04 : 4
Méthode01 de Base
Méthode02 de Derive

Process finished with exit code 0</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Il faut évidement que les identifiants des attributs et méthodes soient distincts. Dans le cas contraire vous vous retrouvez dans une situation de rédéfinition de l&#8217;attribut/méthode qui nécessite l&#8217;usage des mots clé <strong class="red">open</strong> et <strong class="red">override</strong>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_redéfinition_des_attributs_etou_méthodes_dune_classe_de_base"><a class="anchor" href="#_redéfinition_des_attributs_etou_méthodes_dune_classe_de_base"></a>8.3.6. Redéfinition des attributs et/ou méthodes d&#8217;une classe de base</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
La redéfinition d&#8217;un attribut ou d&#8217;une méthode est <strong>fermée</strong> par défaut en Kotlin. Il faudra impérativement pour chaque attribut/méthode redéfini placer en préfixe le mot clé <strong class="red">open</strong>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_redéfinition_des_attributs"><a class="anchor" href="#_redéfinition_des_attributs"></a>Redéfinition des attributs</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Le redéfinition d&#8217;un attribut comporte des limites sur les mots clés <strong>var/val</strong> et sur le <strong>type</strong> de l&#8217;attribut.<br>
On peut redéfinir un <strong class="red">val</strong> vers <strong class="red">var</strong> mais la réciproque est fausse !<br>
Le type peut être redéfini si les deux types sont compatibles (ex: de <strong>Number</strong> vers <strong>Int</strong> )
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La redéfinition peut être utilisée pour modifier la valeur d&#8217;initialisation :</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v4-2d8a9223cfb6e7c8e277501f3bb4e49b9ae4d562.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 11. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Utilisation de <strong>override</strong> pour modifier la valeur d&#8217;initialisation d&#8217;un attribut :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int, val attrib03: Int): Base(arg01, arg02){
    override var attrib04 = 40  // Redéfinition de la valeur</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mais nous pouvions déjà obtenir le même résultat en utilisant tout simplement le bloc <strong>init</strong> du constructeur primaire de la classe dérivée.</p>
</div>
<div class="listingblock">
<div class="title">Utilisation du bloc init pour modifier la valeur d&#8217;initialisation :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int, val attrib03: Int): Base(arg01, arg02){
    init{
        attrib04 = 40
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le principal intérêt de redéfinir un attribut est de personnaliser son getter (accesseur) et/ou son setter (mutateur).</p>
</div>
<div class="listingblock">
<div class="title">Redéfinition des getter et setter d&#8217;un attribut :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int, val attrib03: Int): Base(arg01, arg02){
    override var attrib04 = 40
        get() = field + 10
        set(valeur) {field = valeur - 10}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dans l&#8217;exemple ci-dessous on applique un décalage de la valeur de l&#8217;attribut redéfini aussi bien pour un accès en lecture (getter) ou en écriture (setter).</p>
</div>
</div>
<div class="sect4">
<h5 id="_redéfinition_des_méthodes"><a class="anchor" href="#_redéfinition_des_méthodes"></a>Redéfinition des méthodes</h5>
<div class="paragraph">
<p><strong>Préalable :</strong> Le redéfinition d&#8217;une méthode doit avoir comporter la même signature de la méthode originale.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v5-9173cbbd81034ea8d1b327ff15a15f59faac985c.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 12. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Application sur l&#8217;exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">open class Base(var attrib01: Int, val attrib02: Int){
    open var attrib04: Int = 4
    init{
        println("Constructeur primaire de Base")
    }
    open fun methode01(){
        println("Méthode01 de Base")
    }
}

// Définition de la classe dérivée :
class Derive(arg01: Int, arg02: Int, val attrib03: Int): Base(arg01, arg02){
    init{
        println("Constructeur primaire de Derive")
        println("attrib01 : ${attrib01}\nattrib02 : ${attrib02}\nattrib03 : ${attrib03}")
    }
    override fun methode01(){
        println("Méthode01 redéfinie par Derive")
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_utilisation_du_mot_clé_super"><a class="anchor" href="#_utilisation_du_mot_clé_super"></a>8.3.7. Utilisation du mot clé super</h4>
<div class="paragraph">
<p>Le mot clé <strong class="red">super</strong> à l&#8217;image du mot clé <strong class="red">this</strong> permet de lever l&#8217;ambiguïté sur des références d&#8217;éléments hérités et redéfinis localement dans la classe dérivée.</p>
</div>
<div class="sect4">
<h5 id="_accéder_à_une_méthodeattribut_redéfini"><a class="anchor" href="#_accéder_à_une_méthodeattribut_redéfini"></a>Accéder à une méthode/attribut redéfini</h5>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v6-b16383958cde5ffb02f21795e2148dae043a2b7a.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 13. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;utilisation de <strong>super</strong> avec des attributs et méthodes redéfinis :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">open class Open(){
    open val attrib01: Int = 1
    open val attrib02: Int = 10
    val attrib03: Int = 100
    open fun  methode01(){
        println("Appel de Open")
    }
}

class Derive(): Open(){
    override val attrib01 = 2 * super.attrib01 + super.attrib02
    override val attrib02: Int = super.attrib02
        get() = field + attrib03

    override fun methode01(){
        super.methode01()
        println("Appel de Derive")
    }
}


fun main(){
    val obj = Derive()
    println("obj.attrib01 = ${obj.attrib01}")
    obj.methode01()
    println("obj.attrib02 = ${obj.attrib02}")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>obj.attrib01 = 12
Appel de Open
Appel de Derive
obj.attrib02 = 110

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_appel_des_constructeurs_secondaires"><a class="anchor" href="#_appel_des_constructeurs_secondaires"></a>Appel des constructeurs secondaires</h5>
<div class="paragraph">
<p>L&#8217;intérêt des constructeurs secondaires est d&#8217;assurer l&#8217;héritage avec des classes écrites en Java.
On va ici se contenter d&#8217;illustrer leur usage sur du code purement en Kotlin. Le principe est identique à celui vu précédemment sur les méthodes et attributs mais appliqué aux constructeurs.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_heritage_v7-6ffc0668a78e6dbdb047b14d2a03f56254a8b26f.png" alt="Héritage d&#8217;une classe dérivée à partir de sa classe de base :">
</div>
<div class="title">Figure 14. Héritage d&#8217;une classe dérivée à partir de sa classe de base :</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">open class Base{
    var champ01: Int = 1
    var champ02: Int = 2

    constructor()
    constructor(arg01: Int, arg02: Int): this() {
        champ01 = arg01
        champ02 = arg02
    }
}

class Derive: Base{
    constructor(): super()
    constructor(arg01: Int, arg02: Int): super(arg01, arg02)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_classes_abstraites"><a class="anchor" href="#_les_classes_abstraites"></a>8.3.8. Les classes abstraites</h4>
<div class="sect4">
<h5 id="_règles_propriétés_des_classes_abstraites"><a class="anchor" href="#_règles_propriétés_des_classes_abstraites"></a>Règles &amp; propriétés des classes abstraites</h5>
<div class="ulist">
<ul>
<li>
<p>Une classe abstraite se déclare avec le mot clé <strong class="red">abstract</strong> en préfixe du mot clé <strong class="red">class</strong></p>
</li>
<li>
<p>Une classe abstraite <strong>NE PEUT PAS ETRE INSTANCIEE</strong></p>
</li>
<li>
<p>Une classe abstraite <strong>PEUT ETRE HERITEE</strong> par une classe dérivée.</p>
</li>
<li>
<p>Il n&#8217;est pas nécessaire d&#8217;ouvrir une classe abstraite avec <strong class="red">open</strong>, elle est ouverte par défaut.</p>
</li>
<li>
<p>Une classe abstraite peut avoir des éléments (méthodes/attributs) à la fois non abstraits et abstraits.</p>
</li>
<li>
<p>Les méthodes et attributs d&#8217;une classe abstraite <strong>NE SONT PAS ABSTRAITS</strong> par défaut, il faut le spécifier avec <strong class="red">abstract</strong> en préfixe des identifiants.</p>
</li>
<li>
<p>Les méthodes et attributs d&#8217;une classe abstraite <strong>SONT FERMES</strong> par défaut, il faut les ouvrir avec <strong class="red">open</strong> pour rendre la redéfinition possible (ou utiliser <span class="red">abstract</span> mais à ce moment la redéfinition sera obligatoire).</p>
</li>
<li>
<p>Une méthode marquée comme abstraite <strong>NE PEUT PAS AVOIR DE CORPS</strong>, c&#8217;est à la classe fille de réaliser l&#8217;implémentation complète de la méthode.</p>
</li>
<li>
<p>Un élément défini abstrait devra <strong>OBLIGATOIREMENT REDEFINI</strong> par les classes dérivées avec <strong class="red">override</strong>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Une méthode ou un attribut ne peuvent être déclarés comme <strong>abstract</strong> <span class="underline">uniquement si elle fait partie d&#8217;une classe abstraite.</span>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_intérêt_des_classes_abstraites"><a class="anchor" href="#_intérêt_des_classes_abstraites"></a>Intérêt des classes abstraites</h5>
<div class="ulist">
<ul>
<li>
<p>Définir l&#8217;interface/contrat d&#8217;objets qui seront le résultat de l&#8217;instanciation de classes héritant de la classe abstraite.</p>
</li>
<li>
<p>Comme son nom l&#8217;indique dans une démarche de modélisation objet, la classe de base de plus haut niveau peut collecter des méthodes et attributs communs à des classes dérivée, mais l&#8217;instanciation de cette classe abstraite ne correspond pas à un objet "tangible"/"consistant/"existant".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Exemples :</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nous pouvons définir une classe abstraite <strong>Humain</strong> et la faire hériter par une classe <strong>Homme</strong> et/ou <strong>Femme</strong>. Une instance de Humain n&#8217;a pas de sens alors que nous pouvons instancier une classe <strong>Homme</strong> ou <strong>Femme</strong>.</p>
</li>
<li>
<p>De même nous pouvons créer d&#8217;autres classes abstraites qui devront être héritées avant de pouvoir instancier des objets faisant sens : Une classe <strong>Espece</strong> ou <strong>Animal</strong> devront être héritées de classes comme Chien, Lion, etc, pour instancier des objets animaux.</p>
</li>
<li>
<p>Une classe <strong>Figure</strong> (figure géométrique) sera abstraite et sera héritée de classes comme : <strong>Carre</strong>, <strong>Rectangle</strong>, <strong>Cercle</strong>, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Exemples d&#8217;applications 1 :</strong> Héritage et classes abstraites sur des figures géométriques</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_abstraite_v1-435166348400b61ff55f6c143c6aa660b235ab51.png" alt="Exemple de classes abstraites :">
</div>
<div class="title">Figure 15. Exemple de classes abstraites :</div>
</div>
<div class="listingblock">
<div class="title">Héritage sur plusieurs niveaux :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">abstract class Figure{
    abstract var couleur: String
    abstract val perimetre: Float
    abstract val aire: Float
}

abstract class Polygone: Figure(){
    abstract val nbCotes: Int
}

abstract class Quadrilatere: Polygone(){
    override val nbCotes = 4
}

open class Rectangle(
    override var couleur: String,
    var longueur: Float,
    var largeur: Float
    ): Quadrilatere(){

        final override var perimetre: Float = 0.0F // final permet de mettre fin à l'héritage
            get() {
                field = 2 * (longueur + largeur)
                return field
            }
            // Blocage de l'accès en écriture
            private set // Il faut impérativement repasser l'attribut en final pour rendre privé le setter

        final override var aire: Float = 0.0F // final permet de mettre fin à l'héritage
            get() {
                field = longueur * largeur
                return field
            }
            // Blocage de l'accès en écriture :
            private set // Il faut impérativement repasser l'attribut en final pour rendre privé le setter
}

class Carre(couleur: String, longueur: Float): Rectangle(couleur, longueur, longueur)


fun main(){
    val carre01 = Carre("blanc", 5.0F)
    println("Couleur : ${carre01.couleur}")
    println("Perimètre : ${carre01.perimetre}")
    println("Aire : ${carre01.aire}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Couleur : blanc
Perimètre : 20.0
Aire : 25.0

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exemples d&#8217;applications 2 :</strong> Héritage et classes abstraites sur des personnes</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_abstraite_v2-c904de415a29079354f0ddee1d19cd387763a9f0.png" alt="Exemple de classes abstraites :">
</div>
<div class="title">Figure 16. Exemple de classes abstraites :</div>
</div>
<div class="listingblock">
<div class="title">Héritage sur plusieurs niveaux :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">abstract class Personne(
    val nom: String,
    val prenom: String,
    var age: Int){

    open fun presenter(){
        println("Nom : ${nom}")
        println("Prenom : ${prenom}")
        println("Age : ${age}")
    }
    fun vieillir(){
        age += 1
    }
}

class Employe(nom: String, prenom: String, age: Int, var poste: String): Personne(nom, prenom, age){
    var salaireMensuel: Float = 0.0F

    override fun presenter(){
        super.presenter()
        println("Poste : ${poste}")
        println("Salaire : ${salaireMensuel}")
    }
    fun augmenterSalaire(augmentation: Float){
        salaireMensuel += augmentation
    }
}

fun main(){
    val comptable01 = Employe("DOE", "Joe", 28, "Comptable")
    comptable01.salaireMensuel = 1_950.00F
    comptable01.presenter()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Nom : DOE
Prenom : Joe
Age : 28
Poste : Comptable
Salaire : 1950.0

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_interfaces"><a class="anchor" href="#_les_interfaces"></a>8.3.9. Les interfaces</h4>
<div class="sect4">
<h5 id="_objectifs_et_principes_des_interfaces"><a class="anchor" href="#_objectifs_et_principes_des_interfaces"></a>Objectifs et principes des interfaces</h5>
<div class="paragraph">
<p>Les interfaces sont très proches des classes abstraites au niveau de l&#8217;implémentation. Cependant les objectifs ne sont pas similaires.
Comme nous l&#8217;avions précisé précédemment, une classe abstraite à pour principal objectif de <strong>factoriser</strong> du code. Pour ce faire on extrait de classes concrètes et dérivées la partie du code qui est commun. <br>
Lorsque le processus d&#8217;héritage est suffisamment poussé nous aboutissons à des classes ne correspondant plus à des objets concrets mais à leurs éléments abstraits et communs. Les classes abstraites contiennent notamment la partie commune de l&#8217;implémentation des méthodes. Ces méthodes seront complétées dans les classes dérivée au moyen des mots clés <strong class="red">override</strong> et <strong class="red">super</strong>.</p>
</div>
<div class="paragraph">
<p>Les interfaces n&#8217;ont pas pour objectif de factoriser du code, elles sont un moyen permettant de définir un contrat/interface sans se soucier de son implémentation. Alors qu&#8217;une classe abstraite sera héritée par une lignée/hiérarchie de classes, une interface pourra être héritée sur différentes hiérarchies de classes. Une interface peut contenir des éléments d&#8217;implémentations de méthodes, mais elle permet avant tout de définir les signatures des méthodes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_règles_propriétés_des_interfaces"><a class="anchor" href="#_règles_propriétés_des_interfaces"></a>Règles &amp; propriétés des interfaces</h5>
<div class="ulist">
<ul>
<li>
<p>Tous les éléments contenus dans une interface sont <strong>SYSTEMATIQUEMENT ABSTRAITS</strong>.</p>
</li>
<li>
<p>Les attributs ne peuvent être initialisés sur une valeur mais il est possible de définir le getter (accesseur). Mais à ce moment l&#8217;attribut perd automatiquement son statut de <strong>abstract</strong> et devient <strong>open</strong></p>
</li>
<li>
<p>Une méthode qui implémente un corpes perd automatiquement son staut de <strong>abstract</strong> et deveint <strong>open</strong></p>
</li>
<li>
<p>Une classe peut hériter de plusieurs interfaces.</p>
</li>
<li>
<p>Une interface peut hériter d&#8217;une autre interface.</p>
</li>
<li>
<p>Tous les éléments contenu dans une interface devront être redéfinis par les classes héritant de l&#8217;interface sauf si une interface les a déjà redéfini durant le processus de l&#8217;héritage.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_définition_dune_interface_en_kotlin"><a class="anchor" href="#_définition_dune_interface_en_kotlin"></a>8.3.10. Définition d&#8217;une interface en Kotlin</h4>
<div class="paragraph">
<p>Nous allons illustrer la définition des interfaces en Kotlin à travers de l&#8217;exemple des figures géométriques (exemple utilisé également dans le cadre des classes abstraites).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pour mettre en avant les interfaces d&#8217;un point de vue pédagogique, nous avons pris le parti de n&#8217;utiliser que des interfaces et des classes. Mais d&#8217;un point de vue développement il aurait été pertinent d&#8217;utiliser également des classes abstraites. Un critère pour choisir une implémentation avec une classe abstraite ou une interface est que dès qu&#8217;un élément est redéfini, il est alors peut-être plus judicieux de choisir une classe abstraite. Cependant l&#8217;un des avantage des interfaces, c&#8217;est qu&#8217;une interface ou une classe peuvent héritées de plusieurs interfaces !
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Les langages de programmation n&#8217;autorisent généralement pas l&#8217;héritage de plusieurs classes. La raison est qu&#8217;une méthode pourrait être redéfinie et implémentée différemment par 2 classes qui seraient héritées par une 3ème ! Ce problème est connu sous le nom du <strong>"problème du diamant"</strong>. Les interfaces sont moins sujette à ce problème à partir du fait qu&#8217;elles n&#8217;implémentes pas les méthodes.</p>
</div>
<div class="paragraph">
<p>En cas de conflit de noms sur des attributs et/ou méthodes hérité de plusieurs interfaces, on pourra utiliser l&#8217;instruction suivante pour spéficifier l&#8217;élément en utilisant le mot clé <strong class="red">super</strong> : <strong><em>super&lt;iDinterface&gt;.elmt</em></strong></p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_interface_v1-b3ea317e6b7dc1170bf5f075b88540f9c73211f6.png" alt="Représentation d&#8217;une interface en UML">
</div>
<div class="title">Figure 17. Représentation d&#8217;une interface en UML</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">interface Inter01{
    val attribut01: Int
    fun methode01()
}

interface Inter02{
    val attribut02: Int
    val attribut03: Int
        get() = 2       // get redéfini donc attribut à open au lieu d'abstract.
    fun methode02(){}   // La méthode à un corps, elle devient open au lieu d'abstract.
}

class Cobaye(): Inter01, Inter02{
    override val attribut01 = 1
    override val attribut02 = 2
    override fun methode01() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Application des interfaces sur l&#8217;exemple des figures :</strong></p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/classe_interface_v2-5f071fe35c63771a3f7a60ba8ebf603f05f8ff59.png" alt="Représentation d&#8217;une interface en UML :">
</div>
<div class="title">Figure 18. Représentation d&#8217;une interface en UML :</div>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définitions des interfaces :
// ----------------------------
interface Figure{
    val couleur: String
        get() = "noir"
    val perimetre: Float
    val surface: Float

    fun presenter()
    fun tracer()
}

interface Polygone: Figure{
    val nbCotes: Int
        get() = 3
}

interface PolyGoneRegulier: Polygone{
    val longueur: Float
    override val perimetre: Float
        get() = super.nbCotes * longueur
}

interface Quadrilatere: Polygone{
    override val nbCotes: Int
        get() = 4
}

interface Parallelogramme: Quadrilatere{
    val base: Float
    val hauteur: Float
    override val surface: Float
        get() = base * hauteur
}

// Définition des classes :
// ------------------------
class Rectangle(longueur: Float, largeur: Float): Parallelogramme{
    // Redéfinition des attributs hérités :
    override val base = longueur
    override val hauteur = largeur
    override val perimetre: Float
        get() = 2 * (base + hauteur)
    // Redéfinition des méthodes héritées :
    override fun presenter() {
        println("Je suis un rectangle")
        println("Nombre de côté : ${nbCotes}")
        println("Longueur : ${base}")
        println("Largeur : ${hauteur}")
        println("Périmètre : ${perimetre}")
        println("surface : ${surface}")
    }
    override fun tracer() {
        println("Méthode non implémentée")
    }
}

class Carre(longueur: Float): PolyGoneRegulier, Parallelogramme{
    override val longueur = longueur
    override val base = longueur
    override val hauteur = longueur
    override val perimetre: Float   // Attention si non redéfini utilise nbCotes = 3 de Polygone !!!
        get() = super&lt;Parallelogramme&gt;.nbCotes * longueur // L'utilisation de super&lt;Parallelogramme&gt; lève l'ambiguïté
    override fun presenter(){
        println("Je suis un carré")
        println("Nombre de côté : ${nbCotes}")
        println("Longueur : ${longueur}")
        println("Périmètre : ${perimetre}")
        println("surface : ${surface}")    }

    override fun tracer(){
        println("Méthode non implémentée")
    }
}

fun main(){
    val rectangle01 = Rectangle(10.0f, 5.0f)
    rectangle01.presenter()
    println()
    val carre01 = Carre(5.0f)
    carre01.presenter()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Je suis un rectangle
Nombre de côté : 4
Longueur : 10.0
Largeur : 5.0
Périmètre : 30.0
surface : 50.0

Je suis un carré
Nombre de côté : 4
Longueur : 5.0
Périmètre : 20.0
surface : 25.0

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_les_extensions"><a class="anchor" href="#_les_extensions"></a>8.4. Les extensions</h3>
<div class="sect3">
<h4 id="_objectifs_des_extensions"><a class="anchor" href="#_objectifs_des_extensions"></a>8.4.1. Objectifs des extensions</h4>
<div class="paragraph">
<p>Kotlin ré-utilise les bibliothèques et frameworks déjà disponibles en Java. Il n&#8217;était pas possible de réécrire toutes ces sources en Kotlin.
Afin de permettre d&#8217;enrichir ces éléments existants sans pour autant repartir de zéro, Kotlin intègre un nouveau concept, les extensions. Les extensions permettent de rajouter des méthodes et des attributs à des classes existantes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_principe_de_limplémentation_des_extensions"><a class="anchor" href="#_principe_de_limplémentation_des_extensions"></a>8.4.2. Principe de l&#8217;implémentation des extensions</h4>
<div class="paragraph">
<p>Le principe est très simple on utilisera la notation pointée pour étendre une classe existante avec nos propres éléments.</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;implémentation d&#8217;une extension d&#8217;attribut à la classe String</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">val String.demiTaille: Int
    get() = length / 2

fun main(){
    println("Demi taille du mot  \"anticonstitutionnellement\" : ${"anticonstitutionnellement".demiTaille}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Demi taille du mot  "anticonstitutionnellement" : 12

Process finished with exit code 0</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;implémentation de l&#8217;extension de 2 méthodes aux classes String et Bool</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun String.debuterMajuscule(): String{
    return this[0].toUpperCase().toString() + this.substring(1)
}
fun Int.estPair(): Boolean{
    if (this % 2 == 0) return true else return false
}

fun main(){
    println("le langage Kotlin.".debuterMajuscule())
    println("97 est paire : ${97.estPair()}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Le langage Kotlin.
97 est paire : false

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_allons_plus_loin_avec_les_classes"><a class="anchor" href="#_allons_plus_loin_avec_les_classes"></a>8.5. Allons plus loin avec les Classes</h3>
<div class="sect3">
<h4 id="_redéfinition_de_la_méthode_tostring_de_la_classe_any"><a class="anchor" href="#_redéfinition_de_la_méthode_tostring_de_la_classe_any"></a>8.5.1. Redéfinition de la méthode toString() de la classe Any</h4>
<div class="paragraph">
<p>Comme nous l&#8217;avions déjà précisé, tous les objets de Kotlin vont hériter de la classe Any. Any implémente une méthode <strong class="red">toString()</strong>. Cette méthode est automatiquement appelée lorsque nous désirons convertir un objet en chaîne de caractères. La conversion est implicite lorsque nous passons un objet en argument de la fonction <strong class="red">print()</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Cobaye

fun main(){
    val obj = Cobaye()
    val descriptionObj: String = "Résultat de toString() : " + obj
    println(obj)
    println(descriptionObj)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Cobaye@404b9385
Résultat de toString() : Cobaye@404b9385

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Nous pouvons naturellement redéfinir la méthode <strong class="red">toString()</strong> afin de personnaliser la déscription de l&#8217;objet.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Cobaye(val valeur: Int){
    override fun toString() = "Je suis un objet de la classe Cobaye.\nJ'ai la valeur : ${valeur}."
}

fun main(){
    val obj = Cobaye(38)
    println(obj)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Je suis un objet de la classe Cobaye.
J'ai la valeur : 38.

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_data_class_classe_de_données"><a class="anchor" href="#_les_data_class_classe_de_données"></a>8.5.2. Les Data Class (classe de données)</h4>
<div class="paragraph">
<p>Kotlin propose un type de classe spécialisée pour mémoriser des données.
C&#8217;est le mot clé préfixe <strong class="red">data</strong> qui nous permet de définir ce type de classe.</p>
</div>
<div class="paragraph">
<p>Le compilateur va alors nous faciliter le travail en générant les méthodes suivantes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>copy()</strong></p>
</li>
<li>
<p><strong>equals()</strong></p>
</li>
<li>
<p><strong>hashCode()</strong></p>
</li>
<li>
<p><strong>toString()</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pour que Kotlin accepte de générer une classe <strong>data</strong>, certaines conditions doivent être respectées :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Le constructeur primaire doit contenir au moins un paramètre;</p>
</li>
<li>
<p>Les paramètres du constructeur primaire sont tous précédés de <strong class="red">val</strong> ou <strong class="red">var</strong></p>
</li>
<li>
<p>Une classe <strong>data</strong> peut hériter d&#8217;une interface ou d&#8217;une classe mais elle ne peut pas être ouverte (open) à l&#8217;héritage pour des classes dérivées. De même la classe ne peut être : <strong>abstract</strong>; <strong>inner</strong> ou <strong>sealed</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Exemple :</strong> Consignons des articles dans une classe de données</p>
</div>
<div class="listingblock">
<div class="title">Exemple d&#8217;une classe de données (data class) :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">data class Article(val nom: String, var quantite: Int, var prix: Float)

fun main(){
    val unArticle = Article("Polo", 5, 35.30f)

    println(unArticle)  // Utilisation de la méthode toString()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat produit :</div>
<div class="content">
<pre>article(nom=Polo, quantite=5, prix=35.3)

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Dans notre exemple nous avons généré un objet de la classe de donnée Article. La méthode <strong>toString</strong> a été automatiquement générée pour afficher les différents champs de notre objet.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Les méthodes <strong>hashCode() et equals():</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>hashCode()</strong> est une méthode qui génère un numéro d&#8217;identification pour chaque objet. On va ainsi pouvoir comparer des objets. La méthode <strong>hashCode()</strong> réalise la comparaison et retourn un booléen.</p>
</div>
<div class="listingblock">
<div class="title">Exemple des méthodes hashCode() et equals() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">data class Article(val nom: String, var quantite: Int, var prix: Float)

fun main(){
    val unArticle = Article("Polo", 5, 35.30f)
    println(unArticle)  // Utilisation de la méthode toString()
    println("hashCode unArticle : ${unArticle.hashCode()}")

    val unDoublon = Article("Polo", 5, 35.30f)
    println("hashCode unDoublon : ${unDoublon.hashCode()}")

    println("unArticle identique à unDoublon : ${unArticle.equals(unDoublon)}")</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat produit :</div>
<div class="content">
<pre>Article(nom=Polo, quantite=5, prix=35.3)
hashCode unArticle : -790638800
hashCode unDoublon : -790638800
unArticle identique à unDoublon : true

Process finished with exit code 0</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>La méthode <strong>copy()</strong> :
Cette méthode nous permet de générer rapidement des copies et de modifier à la volée certaines données.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exemple de copy() :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">data class Article(val nom: String, var quantite: Int, var prix: Float)

fun main(){
    val unArticle = Article("Polo", 5, 35.30f)
    println(unArticle)  // Utilisation de la méthode toString()
    println("hashCode unArticle : ${unArticle.hashCode()}")

    val nouveauArticle = unArticle.copy(prix = 42.20f)
    println(nouveauArticle)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Article(nom=Polo, quantite=5, prix=35.3)
hashCode unArticle : -790638800
Article(nom=Polo, quantite=5, prix=42.2)

Process finished with exit code 0</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Le "Destructuring Declarations" (déconstruction) :</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Les <strong>data class</strong> permettent de faire du <em>destructuring declarations</em> (déconstruction en français) c&#8217;est-à-dire que nous allons pouvoir affecter en une seule ligne d&#8217;instruction les données mémorisées dans la <strong>data class</strong> dans des variables d&#8217;accueil.</p>
</div>
<div class="listingblock">
<div class="title">Exemple de copy()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">data class Article(val nom: String, var quantite: Int, var prix: Float)

fun main(){
    val unArticle = Article("Polo", 5, 35.30f)
    val(designation, nombre, montant) = unArticle
    println("designation = $designation")
    println("nombre = $nombre")
    println("montant = $montant")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>designation = Polo
nombre = 5
montant = 35.3

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_classes_anonymes_expressions_objets"><a class="anchor" href="#_classes_anonymes_expressions_objets"></a>8.5.3. Classes anonymes (expressions objets)</h4>
<div class="sect4">
<h5 id="_principe"><a class="anchor" href="#_principe"></a>Principe</h5>
<div class="paragraph">
<p>Le style fonctionnel de Kotlin nous amène à fournir des références d&#8217;objets en arguments de fonctions/méthodes. On peut se retrouver au final à définir une classe et à instancier un objet juste pour fournir l&#8217;identifiant de l&#8217;objet en argument, en dehors de cette application ponctuelle, l&#8217;objet et sa classe n&#8217;auront plus d&#8217;usage.
Afin d&#8217;alléger nos programmes Kotlin offre la possibilité d&#8217;instancier un objet dans l&#8217;appel de fonctions/méthodes.
Il existe différentes façons de procéder, c&#8217;est ce que nous allons voir maintenant.</p>
</div>
</div>
<div class="sect4">
<h5 id="_utilisation_du_mot_clé_object_définition_à_la_volée_dune_classe_from_scratch"><a class="anchor" href="#_utilisation_du_mot_clé_object_définition_à_la_volée_dune_classe_from_scratch"></a>Utilisation du mot clé object (définition à la volée d&#8217;une classe/ "from scratch")</h5>
<div class="paragraph">
<p>Le mot clé <strong class="red">object</strong> va nous permettre d&#8217;instancier un objet en définissant à la volée la définition de la classe.</p>
</div>
<div class="listingblock">
<div class="title">Utilisation du mot clé object pour définir à la volée une classe durant l&#8217;instance de son objet :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition à la volée d'un objet :
val objDemo = object {
    val mot1 = "Bonjour"
    val mot2 = "à tous !"
    override fun toString() = "$mot1 $mot2"
}

fun main(){
    // Passage de l'identifiant à la fonction println
    println(objDemo)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Bonjour à tous !

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_définition_à_la_volée_dune_classe_héritant_dune_classe_etou_interface"><a class="anchor" href="#_définition_à_la_volée_dune_classe_héritant_dune_classe_etou_interface"></a>Définition à la volée d&#8217;une classe héritant d&#8217;une classe et/ou interface</h5>
<div class="paragraph">
<p>Comme pour la définition d&#8217;une classe conventionnelle, nous pouvons avec <strong class="red">object</strong> faire hériter de notre classe d&#8217;une classe et/ou interface.
La syntaxe est proche de la syntaxe utilisée de la syntaxe conventionnelle à la différence que <strong class="red">object</strong> se substitue à <strong class="red">class</strong> et son identifiant.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">// Définition d'une interface :
interface Personne {
    val nom: String
    val prenom: String
}
// Définition d'une classe abstraite :
abstract class PersonneDefaut(
    override val nom: String = "DOE",
    override val prenom: String = "John"
): Personne

// Fonction prennant en argument un objet de type Personne
fun direBonjour(argObj: Personne) {
    println("Bonjour ${argObj.nom} ${argObj.prenom} !")
}

fun main() {
    direBonjour(object: PersonneDefaut(){})
    direBonjour(object: Personne{
        override val nom: String = "DUPONT"
        override val prenom: String = "Jean"})
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Bonjour DOE John !
Bonjour DUPONT Jean !

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_énumérations"><a class="anchor" href="#_les_énumérations"></a>8.5.4. Les énumérations</h4>
<div class="sect4">
<h5 id="_principe_des_énumérations"><a class="anchor" href="#_principe_des_énumérations"></a>Principe des énumérations</h5>
<div class="paragraph">
<p>Les énumérations permettent de consigner des constantes dans un type de données dédié à cet usage.</p>
</div>
<div class="paragraph">
<p>Pour illustrer cela, imaginons que nous désirions consigner tous les mouvements possibles d&#8217;un personnage dans un jeu. Nous allons d&#8217;abord définir le nombre de mouvements, puis les nommer. Enfin, au lieu de mémoriser le nom des mouvements dans une collection (tableau, liste, etc.) on utilisera une énumération.</p>
</div>
<div class="paragraph">
<p>Les énumérations sont des classes <strong>NON INSTANCIABLES</strong> qui contiennent les <strong>constantes</strong> à énumérer. Chaque constante énumérée est elle-même un <strong>OBJET</strong> de la classe <strong>Enum</strong>.</p>
</div>
<div class="paragraph">
<p>Les <strong>constantes</strong> saisies dans une énumération doivent respecter les contraintes syntaxiques des identifiants de variables, fonctions ou classes/objets (seuls les caractères de type lettres, le tiret du bas et les chiffres mais la constante ne doit pas commencer par un chiffre).</p>
</div>
<div class="paragraph">
<p>La classe <strong>Enum</strong> n&#8217;est pas héritable par une classe dérivée. Par contre elle peut hériter d&#8217;une interface (par contre l&#8217;héritage d&#8217;une classe n&#8217;est pas autorisé).</p>
</div>
<div class="paragraph">
<p>Voyons comment procéder à la déclaration d&#8217;une affectation avant de pousser plus loin les caractéristiques et fonctionnement des énumérations.</p>
</div>
</div>
<div class="sect4">
<h5 id="_définition_exploitation_des_énumérations"><a class="anchor" href="#_définition_exploitation_des_énumérations"></a>Définition &amp; exploitation des énumérations</h5>
<div class="paragraph">
<p>Reprenons l&#8217;exemple des directions possibles dans un jeu, nous décidons de reprendre le nom des points cardinaux (<em>NORD</em>, <em>SUD</em>, <em>EST</em> et <em>OUEST</em>). Voici l&#8217;implémentation de l&#8217;énumération correspondante :</p>
</div>
<div class="listingblock">
<div class="title">Enumération contenant les points cardinaux :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">enum class Direction {
    NORD, SUD, EST, OUEST</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dans cet exemple l&#8217;énumération est une classe ayant l&#8217;identifiant Direction. Comme nous l&#8217;avions exposé précédemment, chaque constante est un objet de la classe <strong>Enum</strong>.</p>
</div>
<div class="paragraph">
<p>Autre exemple, nous pourrions également consigner les jours de la semaine :</p>
</div>
<div class="listingblock">
<div class="title">Enumération contenant les jours de la semaine :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">enum class Jours{
    LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_accès_aux_objets_constants_de_lénumération_méthode_tostring"><a class="anchor" href="#_accès_aux_objets_constants_de_lénumération_méthode_tostring"></a>Accès aux objets constants de l&#8217;énumération (méthode toString() )</h6>
<div class="paragraph">
<p>La classe <strong>Enum</strong> est non instanciable et ne possède pas d&#8217;objets compagnons (elle n&#8217;a pas d&#8217;attributs ou de méthode de classes). Par contre nous pouvons utiliser la notation pointée pour accéder à nos objets constants.<br>
Les objets constants implémentent la méthode <strong class="red">toString()</strong> afin de retourner un <strong>String</strong> nous permettant de récupérer le nom de la constante.</p>
</div>
<div class="listingblock">
<div class="title">Accès à une constante d&#8217;une énumération :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println("Direction.EST : ${Direction.EST}")
    println("Jours.SAMEDI is String : ${Jours.SAMEDI is Enum&lt;*&gt;}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Direction.EST : EST
Jours.SAMEDI is String : true

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_méthode_valueof"><a class="anchor" href="#_méthode_valueof"></a>Méthode valueOf()</h6>
<div class="paragraph">
<p>La méthode <strong class="black">valueOf()</strong> permet d&#8217;accéder à une constante comme on le fait avec le notation pointée. La différence réside en 2 points :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>L&#8217;argument fourni à <strong>valueOf()</strong> est le nom de la constante au format <strong>String</strong> (constante entre " ")</p>
</li>
<li>
<p>La méthode lève une exception si la constante est absente de l&#8217;énumération.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Méthode valueOf() de la classe Enum :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(Direction.valueOf("SUD"))
    println(Direction.valueOf("NORD_EST"))
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat : "SUD" est bien affiché, mais "NORD_EST" lève l&#8217;exception</div>
<div class="content">
<pre>SUD
Exception in thread "main" java.lang.IllegalArgumentException: No enum constant Direction.NORD_EST
	at java.base/java.lang.Enum.valueOf(Enum.java:273)
	at Direction.valueOf(enumerations.kt)
	at TestsKt.main(Tests.kt:13)
	at TestsKt.main(Tests.kt)

Process finished with exit code 1</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_méthode_values"><a class="anchor" href="#_méthode_values"></a>Méthode values()</h6>
<div class="paragraph">
<p>La méthode <strong>values()</strong> est la plus intéressante, car elle va nous retourner un tableau (array) de l&#8217;ensemble des constantes de l&#8217;énumération.
On pourra donc appliquer les méthodes et instructions sur ce tableau par exemple pour :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Connaitre le nombre de constantes</p>
</li>
<li>
<p>Itérer l&#8217;ensemble des constantes.</p>
</li>
<li>
<p>Etc.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Exploitation de la méthode <strong>values()</strong> :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println("Direction.values() est-il un Array ? : ${Direction.values() is Array&lt;*&gt;}")
    println("Nombre de direction : ${Direction.values().size}")
    println("Constantes de l'énumération Direction : ${Direction.values().contentToString()}")
    // Affichage des constantes avec forEach() :
    Direction.values().forEach { println(it) }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Direction.values() est-il un Array ? : true
Nombre de direction : 4
Constantes de l'énumération Direction : [NORD, SUD, EST, OUEST]
NORD
SUD
EST
OUEST

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_les_attributs_name_ordinal_des_objets_constants"><a class="anchor" href="#_les_attributs_name_ordinal_des_objets_constants"></a>Les attributs <strong>name</strong> &amp; <strong>ordinal</strong> des objets constants</h6>
<div class="paragraph">
<p>Les objets constants d&#8217;une énumération possède deux attributs :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>name</strong> : Retourne le nom de la constante</p>
</li>
<li>
<p><strong>ordinal</strong> : Retourne le rang/position de la constante dans l&#8217;énumération</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Utilisation des attributs <strong>name</strong> et <strong>ordinal</strong> sur l&#8217;énumération Jours :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
    println(Jours.MARDI.name is String)
    println(Jours.MARDI.ordinal is Int)
    println("${Jours.DIMANCHE} a pour nom : ${Jours.DIMANCHE.name} et est le jour n°${Jours.DIMANCHE.ordinal}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Résultat :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>true
true
DIMANCHE a pour nom : DIMANCHE et le jour n°6

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_utilisation_de_la_boucle_when_avec_les_énumérations"><a class="anchor" href="#_utilisation_de_la_boucle_when_avec_les_énumérations"></a>Utilisation de la boucle <strong>when</strong> avec les énumérations</h6>
<div class="paragraph">
<p>Il peut être intéressant d&#8217;exploiter une énumération avec la structure <strong class="red">when</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Utilisation de <strong class="red">when</strong> sur l&#8217;énumération <strong>Jours</strong> :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun presenterJour(jour: Jours) = "Nous sommes ${jour} le jour n°${jour.ordinal + 1}"

fun main(){
    when(Jours.MARDI){
        Jours.LUNDI -&gt; println(presenterJour(Jours.LUNDI))
        Jours.MARDI -&gt; println(presenterJour(Jours.MARDI))
        Jours.MERCREDI -&gt; println(presenterJour(Jours.MERCREDI))
        Jours.JEUDI -&gt; println(presenterJour(Jours.JEUDI))
        Jours.VENDREDI -&gt; println(presenterJour(Jours.VENDREDI))
        Jours.SAMEDI -&gt; println(presenterJour(Jours.SAMEDI))
        Jours.DIMANCHE -&gt; println(presenterJour(Jours.DIMANCHE))
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Nous sommes MARDI le jour n°2

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ajout_dattributs_aux_objets_constants_dune_énumération"><a class="anchor" href="#_ajout_dattributs_aux_objets_constants_dune_énumération"></a>Ajout d&#8217;attributs aux objets constants d&#8217;une énumération</h5>
<div class="paragraph">
<p>Les énumérations génèrent des objets, nous allons voir maintenant comment ajouter des attributs à nos constantes.</p>
</div>
<div class="paragraph">
<p>Le principe est déclarer un constructeur primaire après l&#8217;identifiant de l&#8217;énumération. Ce constructeur primaire ne s&#8217;appliquera pas à l&#8217;énumération elle-même (l&#8217;énumération n&#8217;est pas instanciable et n&#8217;a donc pas de constructeur) mais à ces objets constants.</p>
</div>
<div class="paragraph">
<p>Pour chaque attribut l&#8217;instruction : <strong>val</strong> <em>identification:</em> <strong>Type</strong> pour définir les attributs.</p>
</div>
<div class="paragraph">
<p>Exemple, nous désirons définir des couleurs. Pour ce faire nous allons à la fois nommer nos couleurs prédéfinis comme nous avions défini les direction et les jours dans les 2 exemples précédents. Mais ensuite techniquement nous avons également besoin de connaitre le codage RGB (Red, Green, Blue) de nos couleurs.</p>
</div>
<div class="listingblock">
<div class="title">Enumération sur le codage RGB avec codage décimal des 3 composantes :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">enum class RGB(val r: Int, val g: Int, val b: Int) {
    ROUGE(255, 0, 0),
    VERT(0, 255, 0),
    BLEU(0, 0, 255),
    NOIR(0, 0, 0),
    BLANC(255, 255, 255)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Maintenant que nous avons défini l&#8217;énumération RGB il est possible de l&#8217;exploiter, dans l&#8217;exemple suivant nous affichons le code RGB du bleu :</p>
</div>
<div class="listingblock">
<div class="title">Exploitation de l&#8217;énumération RGB :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">fun main(){
   println("Le code RGB de la couleur ${RGB.BLEU} est : [${RGB.BLEU.r}, ${RGB.BLEU.g}, ${RGB.BLEU.b}]")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Le code RGB de la couleur BLEU est : [0, 0, 255]

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_personnalisation_de_la_classe_dénumération"><a class="anchor" href="#_personnalisation_de_la_classe_dénumération"></a>Personnalisation de la classe d&#8217;énumération</h5>
<div class="paragraph">
<p>Nous pouvons implémenter nos méthodes à l&#8217;intérieur de l&#8217;énumération. Nous pouvons également implémenter des objets compagnons permettant d&#8217;accéder au méthodes avec une syntaxe plus courte.</p>
</div>
<div class="paragraph">
<p>Pour illustrer notre propos nous allons repartir sur une nouvelle version de l&#8217;énumération Jours. Nous allons nommer cette nouvelle version <strong>JoursSemaine</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Intégration d&#8217;une méthode et d&#8217;un objet compagnon dans une énumération</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">enum class JoursSemaine(var numJour: Int, var nomString: String){
    // Constantes de l'énumération :
    LUNDI(1, "Lundi"),
    MARDI(2, "Mardi"),
    MERCREDI(3, "Mercredi"),
    JEUDI(4, "Jeudi"),
    VENDREDI(5, "Vendredi"),
    SAMEDI(6, "Samedi"),
    DIMANCHE(7, "Dimanche");

    // Méthodes supplémentaires :
    fun customToString() = "Jour n°${numJour} : ${nomString}"

    // Objet compagnon (comportement d'une méthode statique) :
    companion object {
        fun presenter() {
            println(values().contentToString())
        }
    }
}

fun main(){
    println(JoursSemaine.MARDI.customToString())
    JoursSemaine.presenter()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Jour n°2 : Mardi
[LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE]

Process finished with exit code 0</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_redéfinir_une_méthode_selon_lobjet_constant_grâce_à_labstraction"><a class="anchor" href="#_redéfinir_une_méthode_selon_lobjet_constant_grâce_à_labstraction"></a>Redéfinir une méthode selon l&#8217;objet constant grâce à l&#8217;abstraction</h5>
<div class="paragraph">
<p>Les méthodes implémentées vont avoir le même déroulement pour chaque objet constant de l&#8217;énumération. L&#8217;utilisation d&#8217;une méthode abstraite permet de redéfinir la méthode pour chacun des objets.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">enum class JoursSemaine(var numJour: Int, var nomString: String){
    // Constantes de l'énumération :
    LUNDI(1, "Lundi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, c'est la reprise du boulot..."},
    MARDI(2, "Mardi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, mieux que le lundi."},
    MERCREDI(3, "Mercredi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, encore 3 jours."},
    JEUDI(4, "Jeudi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, bientôt le week-end."},
    VENDREDI(5, "Vendredi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, vivement ce soir !"},
    SAMEDI(6, "Samedi")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, c'est le week-end !!!!"},
    DIMANCHE(7, "Dimanche")
        {override fun customToString() = "Jour n°${numJour} : ${nomString}, ça passe trop vite..."};

    // Méthodes supplémentaires :
    abstract fun customToString(): String

    // Objet compagnon (comportement d'une méthode statique) :
    companion object {
        fun presenter() {
            println(values().contentToString())
        }
    }
}

fun main(){
    println(JoursSemaine.LUNDI.customToString())
    println(JoursSemaine.SAMEDI.customToString())
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>Jour n°1 : Lundi, c'est la reprise du boulot...
Jour n°6 : Samedi, c'est le week-end !!!!

Process finished with exit code 0</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Le dernier objet constant de l&#8217;énumération doit se terminer par un <strong class="red">point-virgule</strong> pour pouvoir ajouter à la suite des méthodes.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_utilisation_de_lhéritage_dinterfaces_avec_les_énumérations"><a class="anchor" href="#_utilisation_de_lhéritage_dinterfaces_avec_les_énumérations"></a>Utilisation de l&#8217;héritage d&#8217;interfaces avec les énumérations</h5>
<div class="paragraph">
<p>Maintenant que nous avons implémenter une méthode abstraite, nous allons pouvoir conclure en tirant partie des de l&#8217;héritage d&#8217;une interface. Dans le cadre de notre exemple précédent, cela va rendre le code un peu plus élégant.</p>
</div>
<div class="listingblock">
<div class="title">Implémentation d&#8217;une interface à une énumération :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">interface Jour{
    fun customToString(): String
}

enum class JoursSemaine(var numJour: Int, var nomString: String): Jour{
    // Constantes de l'énumération :
    LUNDI(1, "Lundi")
    {override fun customToString() = "${super.customToString()}, c'est la reprise du boulot..."},
    MARDI(2, "Mardi")
    {override fun customToString() = "${super.customToString()}, mieux que le lundi."},
    MERCREDI(3, "Mercredi")
    {override fun customToString() = "${super.customToString()}, encore 3 jours."},
    JEUDI(4, "Jeudi")
    {override fun customToString() = "${super.customToString()}, bientôt le week-end."},
    VENDREDI(5, "Vendredi")
    {override fun customToString() = "${super.customToString()}, vivement ce soir !"},
    SAMEDI(6, "Samedi")
    {override fun customToString() = "${super.customToString()}, c'est le week-end !!!!"},
    DIMANCHE(7, "Dimanche")
    {override fun customToString() = "${super.customToString()}, ça passe trop vite..."};

    // Redéfinition de la méthode héritée de l'interface :
    override fun customToString() = "Jour n°${numJour} : ${nomString}"

    // Objet compagnon (comportement d'une méthode statique) :
    companion object {
        fun presenter() {
            println(values().contentToString())
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_classes_scellées"><a class="anchor" href="#_les_classes_scellées"></a>8.5.5. Les classes scellées</h4>

</div>
<div class="sect3">
<h4 id="_la_surcharge_dopérateurs"><a class="anchor" href="#_la_surcharge_dopérateurs"></a>8.5.6. La surcharge d&#8217;opérateurs</h4>
<div class="sect4">
<h5 id="_principe_2"><a class="anchor" href="#_principe_2"></a>Principe</h5>
<div class="paragraph">
<p>La surcharge des opérateurs consiste à utiliser les symboles des opérateurs conventionnels unaires et binaires pour appliquer des fonctions/méthodes.<br>
La surcharge s&#8217;appuie sur les types de/des opérande(s) pour déterminer la fonction à appliquer.<br>
Les fonctions/méthodes devant appliquer une surcharge d&#8217;opérateur doivent contenir le mot clé <strong class="red">operator</strong> au début de leur en-tête.</p>
</div>
</div>
<div class="sect4">
<h5 id="_surcharge_dopérateurs_unaires"><a class="anchor" href="#_surcharge_dopérateurs_unaires"></a>Surcharge d&#8217;opérateurs unaires</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Opérateurs</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Méthodes associées</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.unaryPlus()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.unaryMinus()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.not()</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Exemple :</strong><br>
Nous définisons une classe <em>PlusOuMoinsCinqOuRien</em> qui prend une valeur et qui retourne la valeur soustrait de 5 avec l&#8217;opérateur unaire -x. Rajoute 5 avec l&#8217;opérateur +x et retourn 0 avec l&#8217;opérateur !x.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class PlusOuMoinsCinqOuRien(var valeur: Int){
    operator fun unaryMinus(): Int = valeur - 5
    operator fun unaryPlus(): Int = valeur + 5
    operator fun not(): Int = 0
}

fun main(){
    var x = PlusOuMoinsCinqOuRien(17)
    println("x = ${x.valeur}")
    println("-x = ${-x}")
    println("+x = ${+x}")
    println("!x = ${!x}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>x = 17
-x = 12
+x = 22
!x = 0

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_surcharge_des_opérateurs_dincrémentationdécrémentation"><a class="anchor" href="#_surcharge_des_opérateurs_dincrémentationdécrémentation"></a>8.5.7. Surcharge des opérateurs d&#8217;incrémentation/décrémentation</h4>
<div class="paragraph">
<p>Nous retrouvons le même mode de fonctionnement avec les opérateur ++ et - -</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Opérateurs</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Méthodes associées</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a++</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.inc()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a- -</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.dec()</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Exemple :</strong><br>
Nous définissons une classe Coord qui représente les coordonnées <strong>x</strong> et <strong>y</strong> d&#8217;un point.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Coord(var x: Double, var y: Double) {
    operator fun inc(): Coord {
        x = x + 0.5
        y = y + 0.5
        return this
    }
    operator fun dec(): Coord{
        x = x - 0.5
        y = y - 0.5
        return this
    }
    override fun toString() = "[$x, $y]"
}

fun main(){
    var point = Coord(3.0, 7.0)
    println(point++)
    println(point--)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>[3.5, 7.5]
[3.0, 7.0]

Process finished with exit code 0</pre>
</div>
</div>
<div class="sect4">
<h5 id="_surcharge_dopérateurs_binaires"><a class="anchor" href="#_surcharge_dopérateurs_binaires"></a>Surcharge d&#8217;opérateurs binaires</h5>
<div class="paragraph">
<p>Nous ne présenterons pas ici tous les opérateurs binaires, vous pourrez les retrouver sur le site de la documentation de référence de Kotlin (lien disponible plus bas).</p>
</div>
<div class="paragraph">
<p>Pour information, voilà quelques opérateurs binaires que nous allons ensuite appliquer à notre classe <strong>Coord</strong>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Opérateurs</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Méthodes associées</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.plus(b)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a -</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>a.minus(b)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a *</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a.times(b)</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Addition et soustraction de 2 points :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Coord(var x: Double, var y: Double) {
    operator fun plus(b: Coord): Coord {
        var somme = Coord(x + b.x, y + b.y)
        return somme
    }

    operator fun minus(b: Coord): Coord {
        var somme = Coord(x - b.x, y - b.y)
        return somme
    }

    override fun toString() = "[$x, $y]"
}

fun main(){
    var pt1 = Coord(3.0, 7.0)
    var pt2 = Coord(2.0, 3.0)
    println(pt1 + pt2)
    println(pt1 - pt2)

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultats :</div>
<div class="content">
<pre>[5.0, 10.0]
[1.0, 4.0]

Process finished with exit code 0</pre>
</div>
</div>
<div class="paragraph">
<p>Pour aller plus loin, nous vous invitons à consulter la documentation officielle : <a href="https://kotlinlang.org/docs/operator-overloading.html" class="bare">https://kotlinlang.org/docs/operator-overloading.html</a></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_les_classes_génériques"><a class="anchor" href="#_les_classes_génériques"></a>8.5.8. Les classes génériques</h4>
<div class="paragraph">
<p>Les fonctions et les classes peuvent être formulée génériquement, c&#8217;est-à-dire que le type des paramètres n&#8217;est pas spécifié.</p>
</div>
<div class="listingblock">
<div class="title">Exemple :</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">class Duo &lt;T, U&gt;(val para1: T, val para2 : U)

fun main(){
    val objDuo = Duo("One", 1)
    println("objDuo.para1 = ${objDuo.para1}\n" +
            "objDuo.para2 = ${objDuo.para2}")
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Résultat :</div>
<div class="content">
<pre>objDuo.para1 = One
objDuo.para2 = 1

Process finished with exit code 0</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Un projet edu <a href="https://ldv-melun.github.io/sio-slam/">SIO SLAM</a> - build on Antora MPL-2.0 license.</p>
</footer>
<script src="../_/js/site.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
